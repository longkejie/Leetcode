{"./":{"url":"./","title":"Introduction","keywords":"","body":"LeetcodeLeetcode 本人刷题的记录 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1. 前言.html":{"url":"One_question_per_day/1. 前言.html","title":"1. 前言","keywords":"","body":"Leetcode每日一题前言Leetcode每日一题 前言 有一个督促自己的作用吧，从今天开始(2020-11-20)起每天最少也要把每日一题做了 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1004. 最大连续1的个数 III.html":{"url":"One_question_per_day/1004. 最大连续1的个数 III.html","title":"1004. 最大连续1的个数 III","keywords":"","body":"2021-2-19（正月初八）1004. 最大连续1的个数 III思路2021-2-19（正月初八） 1004. 最大连续1的个数 III 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。 返回仅包含 1 的最长（连续）子数组的长度。 示例 1： 输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 输出：6 解释： [1,1,1,0,0,1,1,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2： 输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10 解释： [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示： $1 $0 $A[i]为0或1$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：滑动窗口 本题我们使用一个滑动窗口来实现，我们维护这个滑动窗口中零的个数即可。具体就不细说了。 时间复杂度：$O(n)$,遍历一遍数组即可。 空间复杂度：$O(1)$,只需要额外的几个记录变量即可。 代码 class Solution { public: int longestOnes(vector& A, int K) { int ans = 0, zero = 0; int n = A.size() - 1; int j = 0; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1018. 可被5整除的二进制前缀.html":{"url":"One_question_per_day/1018. 可被5整除的二进制前缀.html","title":"1018. 可被5整除的二进制前缀","keywords":"","body":"2021-1-141018. 可被 5 整除的二进制前缀思路2021-1-14 1018. 可被 5 整除的二进制前缀 给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。 返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。 示例 1： 输入：[0,1,1] 输出：[true,false,false] 解释： 输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。 示例 2： 输入：[1,1,1] 输出：[false,false,false] 示例 3： 输入：[0,1,1,1,1,1] 输出：[true,false,false,false,true,false] 示例 4： 输入：[1,1,1,0,1] 输出：[false,false,false,false,false] 提示： 1 A[i] 为 0 或 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-prefix-divisible-by-5 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：循环遍历+记录 我们使用一个值记录以某位结束时得到的值，值得注意的是，每次计算完都得$mod$ 5，不然最终会超出整形表达范围。 时间复杂度：$O(n)$，遍历一遍数组 空间复杂度：$O(1)$，不需要额外的空间 代码 class Solution { public: vector prefixesDivBy5(vector& A) { vector ans; if (A.empty()) { return ans; } int temp = 0; for (auto &i : A) { temp By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/103. 二叉树的锯齿形层序遍历.html":{"url":"One_question_per_day/103. 二叉树的锯齿形层序遍历.html","title":"103. 二叉树的锯齿形层序遍历","keywords":"","body":"2020-12-22103. 二叉树的锯齿形层序遍历思路2020-12-22 103. 二叉树的锯齿形层序遍历 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], 返回锯齿形层序遍历如下： [ [3], [20,9], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:队列 使用队列来维护我们的层次遍历，值得 注意的是，我们每次遍历一层都是和上层遍历的顺序是相反的，我们可以先将每一层的遍历结果存起来（每次都是从左至右遍历），然后利用一个标记位，如果标记位为0表示从右至左遍历，将我们存起来的结果翻转，将标记位置为1。如果标记位为1，则不需翻转，将标记位改为0即可。然后最后将每层遍历的结果存入答案即可。遍历完一层后，利用队列进行下一层的遍历，直到队列为空结束程序，返回答案。 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector> zigzagLevelOrder(TreeNode* root) { vector> ans; vector num; if (root == NULL) { return {}; } num.push_back(root -> val); ans.push_back(num); num.clear(); queue que; que.push(root); int flag = 0, size = 1; while (que.size()) { int sum = 0; while (size) { TreeNode *node = que.front(); que.pop(); size--; if (node -> left) { num.push_back(node->left->val); que.push(node->left); sum++; } if (node -> right) { num.push_back(node->right->val); que.push(node->right); sum++; } } if (!flag) { reverse(num.begin(), num.end()); flag = 1; }else { flag = 0; } size = sum; if (num.size()) ans.push_back(num); num.clear(); } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1046. 最后一块石头的重量.html":{"url":"One_question_per_day/1046. 最后一块石头的重量.html","title":"1046. 最后一块石头的重量","keywords":"","body":"2020-12-301046. 最后一块石头的重量思路2020-12-30 1046. 最后一块石头的重量 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]， 再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]， 接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]， 最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 提示： 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/last-stone-weight 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：利用multiset维护 本题我们使用一个允许有重复元素的集合来维护我们的数据，值得注意的是，set本来是从下到大排序的，所以我们使用greater重载小于号，使其变为一个从大到小排列的集合。 当集合中元素个数大于等于两个时，我们进行如下操作 每次我们从集合中取出前两个元素，分别存到y和x。并将这两个元素从集合中移除 判断x和y的大小，如果x==y就不需要进行任何操作 如果x 当最终集合中元素个数小于等于2时，退出循环，如果集合个数为0，则返回0，如果集合个数为一个，则返回这个元素即可。 时间复杂度:$O(nlogn)$,每次插入操作所需$logn$的时间复杂度，需要循环n次 空间复杂度:$O(n)$,需要存储n个元素 代码 class Solution { public: int lastStoneWeight(vector& stones) { if (stones.size() == 1) { return stones[0]; } multiset> sset; for (auto &i : stones) { sset.insert(i); } while(sset.size() >= 2) { int y = *sset.begin(); sset.erase(sset.begin()); int x = *sset.begin(); sset.erase(sset.begin()); if (x == y) { continue; }else { sset.insert(y - x); } } if (sset.empty()) return 0; return *sset.begin(); } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1047. 删除字符串中的所有相邻重复项.html":{"url":"One_question_per_day/1047. 删除字符串中的所有相邻重复项.html","title":"1047. 删除字符串中的所有相邻重复项","keywords":"","body":"2021-3-91047. 删除字符串中的所有相邻重复项思路2021-3-9 1047. 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：\"abbaca\" 输出：\"ca\" 解释： 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 提示： $1 $S仅由小写英文字母组成。$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法：栈 本题和括号匹配类似，我们使用栈去模拟即可，当我们想要进来一个字符时，判断是否与栈顶元素相等，如果相等将栈顶元素$pop()$，不相等或者栈为空，将该字符压入栈顶。遍历下一个字符. 值得注意的是我们可以直接通过string来操作。 时间复杂度：$O(n)$，扫描一遍即可。 空间复杂度：$O(n)$，栈所需空间。 代码 class Solution { public: string removeDuplicates(string S) { string ans = \"\"; string s; for (auto &i : S) { if (s.size() && s.back() == i) { s.pop_back(); }else { s.push_back(i); } } return s; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/118. 杨辉三角.html":{"url":"One_question_per_day/118. 杨辉三角.html","title":"118. 杨辉三角","keywords":"","body":"2020-12-06118. 杨辉三角思路2020-12-06 118. 杨辉三角 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: [ ​ [1], ​ [1,1], ​ [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：没啥然后操作 模拟题意输出即可。 直接上代码 代码 class Solution { public: vector> generate(int numRows) { if (numRows > ans; for (int i = 0; i temp; for (int j = 0; j By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1202. 交换字符串中的元素.html":{"url":"One_question_per_day/1202. 交换字符串中的元素.html","title":"1202. 交换字符串中的元素","keywords":"","body":"2021-1-111202. 交换字符串中的元素思路2021-1-11 1202. 交换字符串中的元素 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。 示例 1: 输入：s = \"dcab\", pairs = [[0,3],[1,2]] 输出：\"bacd\" 解释： 交换 s[0] 和 s[3], s = \"bcad\" 交换 s[1] 和 s[2], s = \"bacd\" 示例 2： 输入：s = \"dcab\", pairs = [[0,3],[1,2],[0,2]] 输出：\"abcd\" 解释： 交换 s[0] 和 s[3], s = \"bcad\" 交换 s[0] 和 s[2], s = \"acbd\" 交换 s[1] 和 s[2], s = \"abcd\" 示例 3： 输入：s = \"cba\", pairs = [[0,1],[1,2]] 输出：\"abc\" 解释： 交换 s[0] 和 s[1], s = \"bca\" 交换 s[1] 和 s[2], s = \"bac\" 交换 s[0] 和 s[1], s = \"abc\" 提示： 1 0 0 s 中只含有小写英文字母 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/smallest-string-with-swaps 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：并查集+排序 对于该题我们需要找到所有可以互相交换的下标将它们连通在一起，然后将这些下标的字符串中的字符进行排序，再一一对应原来的字符串交换即可。 并查集，这就不细说了，可自行上网查看。 用到的并查集方法如下 按秩合并 路径压缩 代码 class Solution { public: int n; int size[100005]; int color[100005]; string smallestStringWithSwaps(string s, vector>& pairs) { n = s.size(); for (int i = 0 ;i > mmap; for (int i = 0; i temp; for (auto &j : i.second) { temp.push_back(s[j]); } sort(temp.begin(), temp.end()); int k = 0; for (auto &j : i.second) { s[j] = temp[k++]; } } return s; } void compression() { for (int i = 0; i = size[temp2]) { color[temp2] = temp1; size[temp1] += size[temp2]; }else { size[temp2] += size[temp1]; color[temp1] = temp2; } } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1208. 尽可能使字符串相等.html":{"url":"One_question_per_day/1208. 尽可能使字符串相等.html","title":"1208. 尽可能使字符串相等","keywords":"","body":"2021-2-51208. 尽可能使字符串相等思路2021-2-5 1208. 尽可能使字符串相等 给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例 1： 输入：s = \"abcd\", t = \"bcdf\", cost = 3 输出：3 解释：s 中的 \"abc\" 可以变为 \"bcd\"。开销为 3，所以最大长度为 3。 示例 2： 输入：s = \"abcd\", t = \"cdef\", cost = 3 输出：1 解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。 示例 3： 输入：s = \"abcd\", t = \"acde\", cost = 0 输出：1 解释：你无法作出任何改动，所以最大长度为 1。 提示： $1 $0 $s和t都只含小写英文字母。$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/get-equal-substrings-within-budget 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：双指针+滑动窗口 本题我们使用两个指针来维护一个滑动窗口，我们记录一个字符串的起始坐标$now$,然后往后遍历它的结束坐标$i$,遍历过程中维护一个剩余预算。 如果剩余预算足够支付$i$坐标的开销,将预算减去$i$坐标的开销，将$i++$。 如果不够则计算一个长度$i-now$(表示$now$到$i-1$的字符串总开销小于等于总预算。)，我们的答案则是取多个这样的长度中的最大值，然后我们需要往后移动$now$(now 值得注意的是，当我们$i$坐标遍历到总字符串末尾时，它的剩余开销还是足够的，那么我们需要额外判断一个长度$i+1-now(i==s.size()-1)$,因为此时我们的$s.size()-1$坐标是我们的末尾左边，所以需要加1。 时间复杂度：$O(n)$，每个指针只遍历了一遍。 代码 class Solution { public: int equalSubstring(string s, string t, int maxCost) { int now = 0; int ans = 0; for (int i = 0; i = 0) { maxCost -= abs(s[i] - t[i]); if (i == s.size() - 1) { ans = max(ans, i - now + 1); } }else { ans = max(ans, i - now); while (now = 0) { maxCost -= abs(s[i] - t[i]); }else { now = i + 1; } } } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/131. 分割回文串.html":{"url":"One_question_per_day/131. 分割回文串.html","title":"131. 分割回文串","keywords":"","body":"2021-3-7131. 分割回文串思路2021-3-7 131. 分割回文串 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-partitioning 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递归+回溯 这题不太好分析，需要自行领悟递归和回溯。 本题我们可以使用递归的方法来做，每次我们将我们的回文串压入$temp$，作为我们的一个子串。我们传入一个下标$i$，表示$i$下标前面的字符串已经被分割成若干的回文串了，然后递归处理$i$后的字符串即可。当我们处理完$i$后的字符串的所有情况回溯回来时，$temp$需要$pop_back$,因为以$i$坐标作为分割点的所有情况都处理完了，我们需要往后遍历下一个分割点. 具体看代码吧 代码 class Solution { public: vector> partition(string s) { vector > ans; vector temp; work(s, ans, 0, temp); return ans; } bool is_pa(string str) { int l = 0, r = str.size() - 1; while (l > &ans, int l, vector &temp) { if (l == s.size()) { ans.push_back(temp); } string res = \"\"; for (int i = l; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1319. 连通网络的操作次数.html":{"url":"One_question_per_day/1319. 连通网络的操作次数.html","title":"1319. 连通网络的操作次数","keywords":"","body":"2021-1-231319. 连通网络的操作次数思路2021-1-23 1319. 连通网络的操作次数 用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接 计算机 a 和 b。 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。 给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计 并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 示例 1： 输入：n = 4, connections = [[0,1],[0,2],[1,2]] 输出：1 解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2： 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] 输出：2 示例 3： 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] 输出：-1 解释：线缆数量不足。 示例 4： 输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] 输出：0 提示： $1 $1 \\le connections.length \\le min(n*(n-1)/2, 10^5)$ $connections[i].length == 2$ $0 $connections[i][0] != connections[i][1]$ 没有重复的连接。 两台计算机不会通过多条线缆连接。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：并查集 对于n个结点最少需要n-1条边将它们连通，遍历connection数组利用并查集将属于同一个集合的点连通起来，遍历完connection数组后，再次遍历这n个结点，求出一共有多少个集合，然后我们还需要$集合数-1$条边才能将他们连通，这就是我们所需要的答案。 值得注意的是 当我们的边小于n-1时，不可能有足够的边使这n个结点连通起来。返回$-1$,即可。 我们可以使用$set$,来对集合个数做出统计，它起到一个去重作用。 时间复杂度：$O(m.\\alpha(n))$,其中 m是数组$ \\textit{connections}$的长度，$\\alpha$是阿克曼函数的反函数。 空间复杂度：$O(n)$,需要保存n个结点的集合信息。 代码 class Solution { public: int color[100005] = {0}; int makeConnected(int n, vector>& connections) { set sset; if (connections.size() By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/132. 分割回文串 II.html":{"url":"One_question_per_day/132. 分割回文串 II.html","title":"132. 分割回文串 II","keywords":"","body":"2021-3-8132. 分割回文串 II思路2021-3-8 132. 分割回文串 II 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。 返回符合要求的 最少分割次数 。 示例 1： 输入：s = \"aab\" 输出：1 解释：只需一次分割就可将 s 分割成 [\"aa\",\"b\"] 这样两个回文子串。 示例 2： 输入：s = \"a\" 输出：0 示例 3： 输入：s = \"ab\" 输出：1 提示： $1 $s 仅由小写英文字母组成$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-partitioning-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：无优化的动态规划 本题我们使用动态规划来求解，我们将题目变为求最少的回文字符串，然后再将得到的答案减一就能得到我们的最少分割次数. 动态规划规则如下： 状态定义：$dp[n]$，以下标为n的字符结尾的字符串可以得到的最少回文子串。 状态转移：$dp[n] = min(dp[n],dp[j - 1] + 1)，其中1 时间复杂度：$O(n^3)$，判断是否回文的时间复杂度为$O(n)$. 空间复杂度：$O(n)$，dp数组所需空间. 代码 class Solution { public: int dp[3000] = {0}; bool is_pa(string str, int l, int r) { while (l 方法2：预处理后的动态规划 上述方法中，我们在判断子串是否回文的时候花费了大量是时间，我们可以建议一个数组$vector> temp$,用来存储每个坐标前面能使他们之间的字符串为回文串的坐标，这样我们就不需要每次判断了。 假设对于坐标$i$.我们可以预处理出$i$坐标前面的坐标$j，0 如果$str(j,i)是回文串,我们就将它压入vector[i].push_back(j)$. 时间复杂度：$O(n^2)$，不需要判断. 空间复杂度：$O(n^2)$，temp数组花费的空间. class Solution { public: int dp[3000] = {0}; void work(int l, int r, string str, vector > &temp) { while (l >= 0 && r > temp(n + 5); for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/135. 分发糖果.html":{"url":"One_question_per_day/135. 分发糖果.html","title":"135. 分发糖果","keywords":"","body":"2020-12-24135. 分发糖果思路2020-12-24 135. 分发糖果 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1:输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2: 输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/candy 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 借鉴官方解答 方法一：两次遍历 思路及解法 我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。 左规则：当ratings[i−1] 右规则：当 ratings[i]>ratings[i+1] 时，i号学生的糖果数量将比 i + 1号孩子的糖果数量多。 我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。 具体地，以左规则为例：我们从左到右遍历该数组，假设当前遍历到位置 i，如果有ratings[i−1] 在实际代码中，我们先计算出左规则 left 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 class Solution { public: int candy(vector& ratings) { int n = ratings.size(); vector left(n); for (int i = 0; i 0 && ratings[i] > ratings[i - 1]) { left[i] = left[i - 1] + 1; } else { left[i] = 1; } } int right = 0, ret = 0; for (int i = n - 1; i >= 0; i--) { if (i ratings[i + 1]) { right++; } else { right = 1; } ret += max(left[i], right); } return ret; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1370. 上升下降字符串.html":{"url":"One_question_per_day/1370. 上升下降字符串.html","title":"1370. 上升下降字符串","keywords":"","body":"2020-11-251370. 上升下降字符串思路2020-11-25 1370. 上升下降字符串 给你一个字符串 s ，请你根据下面的算法重新构造字符串： 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。 请你返回将 s 中字符重新排序后的 结果字符串 。 示例 1： 输入：s = \"aaaabbbbcccc\" 输出：\"abccbaabccba\" 解释：第一轮的步骤 1，2，3 后，结果字符串为 result = \"abc\" 第一轮的步骤 4，5，6 后，结果字符串为 result = \"abccba\" 第一轮结束，现在 s = \"aabbcc\" ，我们再次回到步骤 1 第二轮的步骤 1，2，3 后，结果字符串为 result = \"abccbaabc\" 第二轮的步骤 4，5，6 后，结果字符串为 result = \"abccbaabccba\" 示例 2： 输入：s = \"rat\" 输出：\"art\" 解释：单词 \"rat\" 在上述算法重排序以后变成 \"art\" 示例 3： 输入：s = \"leetcode\" 输出：\"cdelotee\" 示例 4： 输入：s = \"ggggggg\" 输出：\"ggggggg\" 示例 5： 输入：s = \"spo\" 输出：\"ops\" 提示： 1 s 只包含小写英文字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/increasing-decreasing-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：桶计数 使用一个数组映射每个字符的下标，然后遍历一遍字符串保存每个字符出现的次数。 然后使用一个死循环，每次从‘a’遍历‘z’，再从‘z’遍历到’a'，每次判断该字符的剩余次数是否大于0，大于0就将它加入到答案字符串后， 然后将次数减一，当每个字符的次数都被遍历完后，退出该循环。 该题结束 代码 class Solution { public: int num[130] = {0}; string sortString(string s) { string ans = \"\"; if (s.empty()) return s; for (auto i : s) { num[i]++; } int flag = 1; while (flag) { flag = 0; for (int i = 'a';i 0) { ans += i; num[i]--; flag = 1; } } for (int i = 'z';i >= 'a'; --i) { if (num[i] > 0 ) { ans += i; num[i]--; } } if (!flag) return ans; } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1423. 可获得的最大点数.html":{"url":"One_question_per_day/1423. 可获得的最大点数.html","title":"1423. 可获得的最大点数","keywords":"","body":"2021-2-61423. 可获得的最大点数思路2021-2-6 【leetcode】第二百题：记录一下，撒花！！！ 1423. 可获得的最大点数 几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 输入：cardPoints = [1,2,3,4,5,6,1], k = 3 输出：12 解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 输入：cardPoints = [2,2,2], k = 2 输出：4 解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 输入：cardPoints = [9,7,7,9,7,7,9], k = 7 输出：55 解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 输入：cardPoints = [1,1000,1], k = 1 输出：1 解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3 输出：202 提示： $1 $1 $1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：滑动窗口 我们使用两个前缀和数组，一个是从前往后，一个是从后往前，然后利用一个$l(0 时间复杂度：$O(n)$,遍历一遍数组 空间复杂度：$O(n)$,保存一个前缀和数组。 代码 class Solution { public: int sum1[100005] = {0}; int sum2[100005] = {0}; int maxScore(vector& cardPoints, int k) { int ans = 0; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/147. 对链表进行插入排序.html":{"url":"One_question_per_day/147. 对链表进行插入排序.html","title":"147. 对链表进行插入排序","keywords":"","body":"2020-11-20147. 对链表进行插入排序思路2020-11-20 147. 对链表进行插入排序 对链表进行插入排序。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 输入: 4->2->1->3 输出: 1->2->3->4 示例 2： 输入: -1->5->3->4->0 输出: -1->0->3->4->5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/insertion-sort-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 1.首先我们需要了解插入排序的基本思想，它分为两个集合，一个有序集合和一个无序集合。每次我们需要从无序集合中选取一个元素插入到有序集合的相应位置，直到无序集合为空为止。 2.了解了插入排序后，我们就可以来讨论如何进行链表的插入排序呢。链表是各种地址链接在一起的集合，在进行插入和删除时，我们应该尤其小心，不然则会导致内存溢出，指针乱指的情况。 3.本题我们首先假设有序集合开始只有一个元素，那就是我们的头结点，为了方便在头部进行插入，我们可以设置一个哑结点，它只是一个虚拟的结点，它指向我们真实的头结点，我们返回的时候，只要返回这个哑结点的next结点即可。 4.我们需要保存的结点有有序集合的尾部结点，这样插入的时候才能方便我们遍历整个有序(集合)链表来寻找相应的插入位置，然后还需要保存无序(集合)链表的第一个结点，和第二个结点，因为当我们将无序(集合)链表的第一个结点插入到有序链表时，我们该怎么获得无序链表的第二个结点呢？这样将会进行不下去，所以应该存储第一个结点和第二个结点。 5.下面我们就可以在有序链表中遍历查找适合无序链表第一个结点插入的位置了，插入后，我们将无序链表第一个结点，指向无序链表的第二个结点，然后重新执行上述插入操作，将无序链表第二个结点也插入进来，直到无序链表没有结点可以插入。 6.值得注意的时，当我们要插入进来的无序链表结点时，如果大于我们有序链表的尾部结点（tail)，在插入后，我们应该修改我们的tail结点为这个插入进来的结点。 基于上述几点，我们就可以来实现我们的代码了。 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* insertionSortList(ListNode* head) { if (head == nullptr) { return head; } ListNode* HEAD = new ListNode(0); HEAD -> next = head; ListNode* current_node = head -> next; ListNode* tail = head; head -> next = NULL; while (current_node != NULL) { ListNode* temp = current_node -> next; head = HEAD; if (current_node -> val > tail->val) { head = tail; } while (head != tail && head -> next -> val val) { head = head -> next; } current_node -> next = head -> next; head -> next = current_node; if (head == tail) tail = current_node; current_node = temp; } return HEAD -> next; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/148. 排序链表.html":{"url":"One_question_per_day/148. 排序链表.html","title":"148. 排序链表","keywords":"","body":"2020-11-21148. 排序链表思路2020-11-21 148. 排序链表 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2： 输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3： 输入：head = [] 输出：[] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 本题和昨日的147. 对链表进行插入排序感觉是差不多的，都是对链表进行排序，我们将昨天那个代码，一贴，一提交肯定也是可以过的，结果如下： 方法1：插入排序 但是这个时间是不是有点太长了？ 因为插入排序的时间复杂度为O(n^2),题目要求我们在O(nlogn) 时间内完成，所以我们肯定是不能再利用插入排序来做了。 代码 代码和昨天的一样就不贴了。 方法2：利用multimap 我们利用STL内的关联容器multimap来进行排序，它内部是红黑树实现的，排序时间复杂度为O(nlogn)（每次插入的时间复杂度为O(logn）插入n次）,空间复杂度为O(n)（存n个结点）。 我们定义key值为每个结点的val值，根据这个值的大小来排序，然后依次将每个结点插入即可。 插入完成后，我们遍历我们的整个map，依次取出，然后就是一个有序的链表了。 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { if (head == nullptr) return head; multimap mmap; ListNode* HEAD = new ListNode(0); while (head != NULL) { mmap.insert(multimap::value_type(head -> val, head)); head = head -> next; } ListNode* tail = HEAD; for (auto i : mmap) { tail -> next = i.second; tail = tail -> next; } tail->next = NULL; return HEAD -> next; } }; 結果如下： 比插入排序快一点，但是好像也没好到哪里去。 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1579. 保证图可完全遍历.html":{"url":"One_question_per_day/1579. 保证图可完全遍历.html","title":"1579. 保证图可完全遍历","keywords":"","body":"2021-1-271579. 保证图可完全遍历思路2021-1-27 1579. 保证图可完全遍历 Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边： 类型 1：只能由 Alice 遍历。 类型 2：只能由 Bob 遍历。 类型 3：Alice 和 Bob 都可以遍历。 给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以 全遍历的。 返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。 示例 1： 输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] 输出：2 解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历 所以可以删除的最大边数是 2 。 示例 2： 输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] 输出：0 解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。 示例 3： 输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] 输出：-1 解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。 提示： $1 $1 n (n-1) / 2)$ $edges[i].length == 3$ $1 $1 所有元组 (typei, ui, vi) 互不相同 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：并查集 我们遍历每一条边，利用并查集将边两边的点加入到一个集合中。边的遍历方法如下： 首先我们应该先遍历类型为3的边，因为为了达到删除的边最多，而我们类型为3的边相当于类型为1的边和类型为2的边。所以它权重比较大，我们先遍历完类型为3的边，当发现两个点已经属于一个集合时，将答案$ans$加1. 然后就遍历类型为1和类型为2的边，对于每次遍历，判断这两个点是否属于一个集合，是的话将答案$ans$加1，表示可以将这条边删除。 时间复杂度：$O(m.\\alpha(n))$,m是数组edges的长度，$\\alpha$是阿克曼函数的反函数。 空间复杂度：$O(n)$，需要保存每个点的集合信息。 代码 class Solution { public: int color1[100005]; int color2[100005]; int maxNumEdgesToRemove(int n, vector>& edges) { int type1 = 0, type2 = 0, ans = 0; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/1631. 最小体力消耗路径.html":{"url":"One_question_per_day/1631. 最小体力消耗路径.html","title":"1631. 最小体力消耗路径","keywords":"","body":"2021-1-291631. 最小体力消耗路径思路2021-1-29 1631. 最小体力消耗路径 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在 左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个 方向之一移动，你想要找到耗费 体力 最小的一条路径。 一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。 请你返回从左上角走到右下角的最小 体力消耗值 。 示例 1： 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2： 输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3： 输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] 输出：0 解释：上图所示路径不需要消耗任何体力。 提示： $rows == heights.length$ $columns == heights[i].length$ $1 $1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-with-minimum-effort 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：BFS + 优先队列 本题我们使用宽度优先搜索来解答，但是值得注意的是，我们需要使用优先队列来存储状态，因为我们每次需要先遍历所有子路径中高度差绝对值 的 最大值 的较小值，再遍历较大值，这样就能保证我们的局部最优点。BFS四大要素如下： 起始状态：坐标为$(0,0)点$，路径高度差绝对值的最大值为0 终止状态：坐标为$(row-1,col-1)$,路径高度差绝对值的最大值是所有值中最小的那个值，即为我们的答案。 状态转移：每次我们遍历四个方向，然后更新高度差为当前结点高度和前一个结点高度之差以及到达前一个结点的路径之间的那个最大高度差这两者之间的较大值。 去重：我们需要从队列中取出改点时，才能将改点去重，因为只有这样到达改点的路径中那个高度绝对值的最大值才是最小。 我们需要统计每一条到达$(row-1,col-1)$点的路径，取其中最小值即为我们的答案。 时间复杂度：$O(r\\times{c}\\times\\log(r\\times{c}))$，r为行数，c为列数，需要遍历$r\\times{c}$个点，每次优先队列的$push$和$pop$需要$log(r\\times{c})$的时间复杂度。 空间复杂度：$O(r\\times{c})$，需要保存每个结点的状态。 代码 class Solution { public: struct node { int x, y, step; }; int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0}; int mark[105][105] = {0}; int minimumEffortPath(vector>& heights) { int n = heights.size(); int m = heights[0].size(); int ans = INT32_MAX; auto cmp = [](node a, node b){return a.step > b.step;}; priority_queue, decltype(cmp)> que(cmp); que.push(node{0, 0, 0}); if (n == 1 && m == 1) { return 0; } while (que.size()) { node temp = que.top(); que.pop(); mark[temp.x][temp.y] = 1; for (int i = 0;i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/164. 最大间距.html":{"url":"One_question_per_day/164. 最大间距.html","title":"164. 最大间距","keywords":"","body":"2020-11-26164. 最大间距思路2020-11-26 164. 最大间距 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 示例 1: 输入: [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 说明: 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-gap 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：利用multimap，进行排序 遍历一遍数组，将元素一个一个的插入到multimap中，然后依次比较multimap相邻元素的差值，选择一个最大的作为答案返回即可。 时间复杂度：O(nlogn)，每次插入时需要logn的时间复杂度，需要插入n个结点。 空间复杂度：O(n)，需要保存n个结点。 思路比较简单，复杂度也远远没有满足题目要求的线性时间复杂度。 先通过再做优化 代码 class Solution { public: int maximumGap(vector& nums) { if (nums.size() mmap; for (int i = 0; i ::value_type(nums[i],i)); } int mmax = 0; multimap::iterator i1 = mmap.begin(); int now = i1 -> first; i1++; for (i1; i1 != mmap.end(); ++i1) { mmax = max(mmax,i1->first - now); now = i1 -> first; } return mmax; } }; 方法2：基数排序 基数排序是一种基于整数的排序，算是一种比较快的排序算法了，可自行在网上去搜索一下它的算法思想，这里我就不赘述了。 时间复杂度：O(n)，它是以每个整数的每一位来进行排序的，每次通过一位来进行排序，每次排序遍历两遍数组，因为一个int整形最大也就20位，所以只需进行常数级别的遍历就可以完成排序了。 空间复杂度：O(n),每次排序，都要基于一个桶来暂时存储排序后数据，然后再将该数据赋给原数组。 代码 class Solution { public: int maximumGap(vector& nums) { if (nums.size() buf(n,0); while (exp cnt(10); for (int i = 0; i = 0; --i) { int digit = (nums[i] / exp) % 10; buf[cnt[digit] - 1] = nums[i]; cnt[digit]--; } copy(buf.begin(),buf.end(),nums.begin()); exp *= 10; } int ans = 0; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/188. 买卖股票的最佳时机 IV.html":{"url":"One_question_per_day/188. 买卖股票的最佳时机 IV.html","title":"188. 买卖股票的最佳时机 IV","keywords":"","body":"2020-12-28188. 买卖股票的最佳时机 IV思路2020-12-28 188. 买卖股票的最佳时机 IV 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 0 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划 与本题类似的一共有六题，链接分别如下 121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费 解题思路如下网站！！！ 股票买卖问题解题大全 前面两道还不用涉及到动态规划，后面几道思路类似。 代码 121. 买卖股票的最佳时机 class Solution { public: int maxProfit(vector& prices) { if (!prices.size()) return 0; int ans = 0; int min = prices[0]; for (int i = 1 ; i 122. 买卖股票的最佳时机 II class Solution { public: int maxProfit(vector& prices) { if (!prices.size()) return 0; int ans = 0; for (int i = 1; i prices[i - 1]){ ans += prices[i] - prices[i - 1]; } } return ans; } }; 123. 买卖股票的最佳时机 III class Solution { public: int maxProfit(vector& prices) { if (prices.size() > > dp(prices.size() + 1, vector>(3, vector(2))); for (int i = 1; i 188. 买卖股票的最佳时机 IV class Solution { public: int maxProfit(int k, vector& prices) { if (prices.empty()) { return 0; } vector > > dp(prices.size() + 1,vector >(k + 1, vector(2))); for (int i = 1; i 309. 最佳买卖股票时机含冷冻期 class Solution { public: int maxProfit(vector& prices) { if (prices.size() > dp(prices.size() + 1, vector(2)); dp[0][1] = -prices[0]; for (int i = 1;i 714. 买卖股票的最佳时机含手续费 class Solution { public: int maxProfit(vector& prices, int fee) { int n = prices.size(); vector> dp(n, vector(2)); dp[0][0] = 0, dp[0][1] = -prices[0]; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/204. 计数质数.html":{"url":"One_question_per_day/204. 计数质数.html","title":"204. 计数质数","keywords":"","body":"2020-12-3204. 计数质数思路2020-12-3 204. 计数质数 统计所有小于非负整数 n 的质数的数量。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2： 输入：n = 0 输出：0 示例 3： 输入：n = 1 输出：0 提示： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-primes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：线性筛 本题我们可以利用线性筛的方法，将素数筛选出来，计数即可。 废话不多说上代码。 懂的都懂 代码 class Solution { public: int prime[10000000] = {0}; int countPrimes(int n) { for (int i = 2; i n) break; prime[i * prime[j]] = 1; if (i % prime[j] == 0) break; } } return prime[0]; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/205. 同构字符串.html":{"url":"One_question_per_day/205. 同构字符串.html","title":"205. 同构字符串","keywords":"","body":"2020-12-27205. 同构字符串思路2020-12-27 205. 同构字符串 本题是下题的简化版。 290. 单词规律 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = \"egg\", t = \"add\" 输出: true 示例 2: 输入: s = \"foo\", t = \"bar\" 输出: false 示例 3: 输入: s = \"paper\", t = \"title\" 输出: true 说明: 你可以假设 s 和 t 具有相同的长度。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/isomorphic-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：两个哈希表 我们利用两个哈希表，将两个字符串的相应规律存起来，然后一一比较两个规律，如果不同返回false，如果遍历完所有都相同的话，返回true。 时间复杂度：O(n)，需要遍历两个字符串。 空间复杂度：O(n)，需要两个哈希表存储每个的对应关系。 代码 class Solution { public: bool isIsomorphic(string s, string t) { if (s.empty()) { return true; } unordered_map > mmap; unordered_map > mmap1; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/217. 存在重复元素.html":{"url":"One_question_per_day/217. 存在重复元素.html","title":"217. 存在重复元素","keywords":"","body":"2020-12-13217. 存在重复元素思路2020-12-13 217. 存在重复元素 给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:哈希表 我们遍历一遍数组，每次遍历到一个值，就利用哈希表判断它是否在前面出现过，如果出现过返回true,否则将它加入哈希表，如果遍历完数组还没返回true说明没有重复元素出现，返回false即可 时间复杂度:O(n) 空间复杂度:O(n) 思路较为简单，代码演示如下 代码 class Solution { public: bool containsDuplicate(vector& nums) { unordered_set s; for (auto &i : nums) { if (s.find(i) != s.end()) { return true; }else { s.insert(i); } } return false; } }; 方法2：排序+比较相邻元素 我们将数组排序，然后相同的元素肯定相邻，只要判断相邻的元素是否相等，我们就能得知是否有重复元素。 思路较为简单 时间复杂度：O(nlogn) 空间复杂度：O(logn) 排序所需要的递归深度 代码演示如下 代码 class Solution { public: bool containsDuplicate(vector& nums) { if (nums.size() By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/222. 完全二叉树的节点个数.html":{"url":"One_question_per_day/222. 完全二叉树的节点个数.html","title":"222. 完全二叉树的节点个数","keywords":"","body":"2020-11-24222. 完全二叉树的节点个数思路2020-11-24 222. 完全二叉树的节点个数 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 输入: 1 / \\ 2 3 / \\ / 4 5 6 输出: 6 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-complete-tree-nodes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：BFS 本题是一个关于完全二叉树的搜索问题，对于二叉树的搜索我们可以使用层次遍历的方法来做。 这方法比较简单，使用队列维护我们的结点，每次取出一个结点就将答案加1，然后将它的左孩子节点和右孩子节点放入队列，等待后续的遍历。 时间复杂度：O(N)， 需要遍历N个结点 空间复杂度：O(N)， 我们需要用队列来维护每个结点。 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int countNodes(TreeNode* root) { int ans = 0; if (root == nullptr) { return ans; } queue que; que.push(root); while (!que.empty()) { TreeNode *temp = que.front(); que.pop(); ans ++; if (temp -> left != nullptr) { que.push(temp -> left); if (temp -> right != nullptr) { que.push(temp -> right); } } } return ans; } }; 方法2：位运算+二分搜索 该方法是看该题Leetcode题解的大佬的，觉得挺有意思的，来记录一下。 1.对于该种解法，我们需要知道该二叉树的高度（root为第0层），来得到该完全二叉树的结点个数的所有可能。 由于完全二叉树，最下面一层的节点都集中在该层最左边的若干位置，所以我们一直遍历左结点，直到遍历到叶子结点即可得到相应的高度。 2.得知高度h后，我们就能知道我们的二叉树的结点个数的所有可能了。 具体做法是，根据节点个数范围的上下界得到当前需要判断的节点个数 k，如果第 k 个节点存在，则节点个数一定大于或等于 k，如果第 k 个节点不存在，则节点个数一定小于 k，由此可以将查找的范围缩小一半，直到得到节点个数。 如何判断第 k个节点是否存在呢？如果第 k个节点位于第 h层，则 k的二进制表示包含 h+1位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1表示移动到右子节点。通过位运算得到第 k个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 k 个节点是否存在。 怕自己写不清楚所以复制了一下它的题解，具体题解见下面链接： 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetco-2/ 复杂度分析： 代码 代码纯自己创作。如有雷同，实属巧合 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int temp; int countNodes(TreeNode* root) { int ans = 0; int high = 0; if (root == nullptr) { return ans; } TreeNode* node = root; while (node -> left != nullptr) { high++; node = node -> left; } int l = (1 > 1; if (exist(mid,root)) { l = mid; }else { r = mid - 1; } } return l; } bool exist(int x, TreeNode* root) { while (temp) { if ((x & temp) != 0) { root = root -> right; }else { root = root -> left; } if (root == nullptr) return false; temp >>= 1; } return root != nullptr; } }; 值得注意的是，位运算一定要打()提高它的运算优先级，不然真的容易出错。 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/228. 汇总区间.html":{"url":"One_question_per_day/228. 汇总区间.html","title":"228. 汇总区间","keywords":"","body":"2021-1-10228. 汇总区间思路2021-1-10 228. 汇总区间 给定一个无重复元素的有序整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属 某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： \"a->b\" ，如果 a != b \"a\" ，如果 a == b 示例 1： 输入：nums = [0,1,2,4,5,7] 输出：[\"0->2\",\"4->5\",\"7\"] 解释：区间范围是： [0,2] --> \"0->2\" [4,5] --> \"4->5\" [7,7] --> \"7\" 示例 2： 输入：nums = [0,2,3,4,6,8,9] 输出：[\"0\",\"2->4\",\"6\",\"8->9\"] 解释：区间范围是： [0,0] --> \"0\" [2,4] --> \"2->4\" [6,6] --> \"6\" [8,9] --> \"8->9\" 示例 3： 输入：nums = [] 输出：[] 示例 4： 输入：nums = [-1] 输出：[\"-1\"] 示例 5： 输入：nums = [0] 输出：[\"0\"] 提示： 0 -231 nums 中的所有值都 互不相同 nums 按升序排列 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/summary-ranges 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：循环+标记 本题思路较为简单，但是要把整形转为string较为复杂，后面发现有to_string函数，可以直接转换，那么这题就简单了。不细说了 代码如下： 时间复杂度：$O(n)$，遍历一遍数组 空间复杂度：$O(1)$，不需要额外的空间 代码 class Solution { public: vector summaryRanges(vector& nums) { vector ans; if (nums.empty()) { return ans; } int end; string temp; for (auto &i : nums) { if (temp.empty()) { temp = to_string(i); end = i; }else { if (i == end + 1) { end = i; }else { if (to_string(end) != temp) { temp += \"->\"; temp += to_string(end); } ans.push_back(temp); temp = to_string(i); end = i; } } } if (to_string(end) != temp) { temp += \"->\"; temp += to_string(end); } ans.push_back(temp); return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/239. 滑动窗口最大值.html":{"url":"One_question_per_day/239. 滑动窗口最大值.html","title":"239. 滑动窗口最大值","keywords":"","body":"2021-1-2239. 滑动窗口最大值思路2021-1-2 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例 1： 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2： 输入：nums = [1], k = 1 输出：[1] 示例 3： 输入：nums = [1,-1], k = 1 输出：[1,-1] 示例 4： 输入：nums = [9,11], k = 2 输出：[11] 示例 5： 输入：nums = [4,-2], k = 2 输出：[4] 提示： $1 $-10^4 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sliding-window-maximum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 本题与下题类似 剑指 Offer 59 - I. 滑动窗口的最大值 但是本题的数值较大，不能使用暴力解！！！ 方法1：双端队列+单调队列 窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque ： deque内 仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i - 1] ，需将 deque内的对应元素一起删除。 deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j + 1] ，需将 deque 内所有 算法流程： 1.初始化： 双端队列 deque ，结果列表 ans ，数组长度 n ； 2.滑动窗口： 左边界范围 i∈[1−k,n+1−k] ，右边界范围 j∈[0,n−1] ； ​ a.若 i > 0且 队首元素 deque[0] == 被删除元素 nums[i - 1],则队首元素出队； ​ b.删除 deque内所有 ​ c.将nums[j] 添加至 deque尾部； ​ d.若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 ans 。 3.返回值： 返回结果列表 ans 。 作者：jyd 链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 class Solution { public: vector maxSlidingWindow(vector& nums, int k) { deque deq; vector ans; if (nums.size() == 1) { return {nums[0]}; } for (int i = 0; i deq.back()) { deq.pop_back(); } deq.push_back(nums[i]); } ans.push_back(deq.front()); for (int i = k; i deq.back()) { deq.pop_back(); } if (deq.size() && deq.front() == nums[i - k]) { deq.pop_front(); } deq.push_back(nums[i]); ans.push_back(deq.front()); } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/242. 有效的字母异位词.html":{"url":"One_question_per_day/242. 有效的字母异位词.html","title":"242. 有效的字母异位词","keywords":"","body":"2020-11-22242. 有效的字母异位词思路2020-11-22 242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true 示例 2: 输入: s = \"rat\", t = \"car\" 输出: false 说明: 你可以假设字符串只包含小写字母。 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-anagram 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希表 先首先判断s和t的字符串长度是否相等，不相等直接输出false 然后利用哈希表映射每个字符在s中出现的次数。 然后遍历一遍t字符串，每遇到一个字符，就将他在哈希表中映射到的次数减1。 直至遇到映射的次数小于等于0，那么直接返回false 如果遍历完整个字符串都没有返回false 那么说明t是s的字母异位词，返回true 代码 class Solution { public: bool isAnagram(string s, string t) { if (t.size() != s.size()) { return false; } unordered_map mmap; for (auto i : s) { mmap[i]++; } for (auto i : t) { if (mmap[i] By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/290. 单词规律.html":{"url":"One_question_per_day/290. 单词规律.html","title":"290. 单词规律","keywords":"","body":"2020-12-16290. 单词规律思路2020-12-16 290. 单词规律 给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = \"abba\", str = \"dog cat cat dog\" 输出: true 示例 2: 输入:pattern = \"abba\", str = \"dog cat cat fish\" 输出: false 示例 3: 输入: pattern = \"aaaa\", str = \"dog cat cat dog\" 输出: false 示例 4: 输入: pattern = \"abba\", str = \"dog dog dog dog\" 输出: false 说明: 你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/word-pattern 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希表 我们利用两个哈希表，将规律和字符串的相应规律存起来，然后一一比较两个规律，如果不同返回false，如果遍历完所有都相同的话，返回true。 时间复杂度：O(n+m)，需要遍历字符串和规律字符串。 空间复杂度：O(n+m)，需要两个哈希表存储每个的对应关系。 代码 class Solution { public: bool wordPattern(string pattern, string s) { unordered_map > mmap; unordered_map > mmap1; vector str; string temp = \"\"; if (pattern.empty() || s.empty()) { return false; } for (int i = 0 ; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/303. 区域和检索 - 数组不可变.html":{"url":"One_question_per_day/303. 区域和检索 - 数组不可变.html","title":"303. 区域和检索 - 数组不可变","keywords":"","body":"2021-3-1303. 区域和检索 - 数组不可变思路2021-3-1 三月的第一道题 303. 区域和检索 - 数组不可变 给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ...,nums[j])） 示例： 输入： [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"] [[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出： [null, 1, -1, -3] 解释： NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3) numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示： $0 $-10^5 $0 最多调用 $10^4$ 次 sumRange 方法 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/range-sum-query-immutable 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：前缀和 本题需要我们快速求出数组（数组不可变）的区间和，所以我们只需要求出数组每个位置的前缀和即可。当我们想要知道数组$i$到$j$之间的数字之和时，我们计算前缀和数组$sums[j]$-$sums[i-1]$即可。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 class NumArray { public: int sum[100000] = {0}; NumArray(vector& nums) { for (int i = 1; i sumRange(i,j); */ By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/304. 二维区域和检索 - 矩阵不可变.html":{"url":"One_question_per_day/304. 二维区域和检索 - 矩阵不可变.html","title":"304. 二维区域和检索 - 矩阵不可变","keywords":"","body":"2021-3-2304. 二维区域和检索 - 矩阵不可变思路2021-3-2 304. 二维区域和检索 - 矩阵不可变 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。 示例： 给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] $sumRegion(2, 1, 4, 3) -> 8$ $sumRegion(1, 1, 2, 2) -> 11$ $sumRegion(1, 2, 2, 4) -> 12$ 提示： 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划+二维前缀和 不好解释就直接上代码了，代码中理解吧。 复杂度分析 时间复杂度：初始化$ O(mn)$，每次检索 $O(1)$，其中 m 和n分别是矩阵$ \\textit{matrix}$的行数和列数。 初始化需要遍历矩阵 $\\textit{matrix}$计算二维前缀和，时间复杂度是$O(mn)$。 每次检索的时间复杂度是 $O(1)$。 空间复杂度：$O(mn)$，其中 m 和 n 分别是矩阵 $\\textit{matrix}$ 的行数和列数。需要创建一个 m+1 行 n+1 列的二维前缀和数组 $\\textit{dp}$ 代码 class NumMatrix { public: vector> dp; NumMatrix(vector>& matrix) { int m = matrix.size(); if (m > 0) { int n = matrix[0].size(); dp.resize(m + 5, vector(n + 5, 0)); for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/316. 去除重复字母.html":{"url":"One_question_per_day/316. 去除重复字母.html","title":"316. 去除重复字母","keywords":"","body":"2020-12-20316. 去除重复字母思路2020-12-20 316. 去除重复字母 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同 示例 1： 输入：s = \"bcabc\" 输出：\"abc\" 示例 2： 输入：s = \"cbacdcbc\" 输出：\"acdb\" 提示： 1 s 由小写英文字母组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicate-letters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：单调栈 本题我们使用一个栈来维护，当我们进来的字符比栈顶元素的ASCII小时，我们就要考虑是否将栈顶元素出栈，将该字符压入栈，这样可使ASCII较小的字符尽量的放入前面，达到字典序最小的目的。 对于满足上述出栈条件，我们还需要考虑下面几点。 1.出栈的这个字符后续是否还会出现，如果不会再出现，就不能将它出栈。 2.栈是否为空，为空就不能出栈 3.压入进来的字符是否在栈中出现，出现过就不能再进入栈，那么栈顶元素就不必出栈。 每次出栈的字符，需将标记改为0，表示该字符在栈中没有出现过了。 完成出栈操作后，就将该进来的字符压入栈，需要标记位0才能压入，然后将这个字符在字符串中的次数减一，表示后续不会再访问到该下标，该字符标记为1，表示已经出现过了。 时间复杂度：O(n)，虽然有两层循环，但每个字符最多出栈入栈一次。 空间复杂度：O(K)，K为26，最多有26个字符。 代码 class Solution { public: string removeDuplicateLetters(string s) { unordered_map m,v; deque deq; for (auto i : s) { m[i]++; } for (auto i : s) { while (!deq.empty() && i 0 && v[i] == 0){ v[deq.back()] = 0; deq.pop_back(); } if (v[i] == 0) { deq.push_back(i); v[i] = 1; } m[i]--; } return {deq.begin(),deq.end()}; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/331. 验证二叉树的前序序列化.html":{"url":"One_question_per_day/331. 验证二叉树的前序序列化.html","title":"331. 验证二叉树的前序序列化","keywords":"","body":"2021-3-2331. 验证二叉树的前序序列化思路2021-3-2 331. 验证二叉树的前序序列化 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # 例如，上面的二叉树可以被序列化为字符串 \"9,3,4,#,#,1,#,#,2,#,6,#,#\"，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 \"1,,3\" 。 示例 1: 输入: \"9,3,4,#,#,1,#,#,2,#,6,#,#\" 输出: true 示例 2: 输入: \"1,#\" 输出: false 示例 3: 输入: \"9,#,#,1\" 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：栈模拟 题解借鉴官方的，链接如下： 我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。 二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时： 如果遇到了空节点，则要消耗一个槽位； 如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。 此外，还需要将根节点作为特殊情况处理。 我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当 到空节点时，仅将栈顶元素减 1；当遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0 就立刻将栈顶弹出。 遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽 位数量不足，则序列不合法。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：$O(n)$，遍历一遍字符串即可。 空间复杂度：$O(n)$，栈空间。 代码 class Solution { public: bool isValidSerialization(string preorder) { if (preorder.empty()) return false; stack s; s.push(0); if (preorder[0] == '#') s.pop(); int flag = 0; int j = 0; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/338. 比特位计数.html":{"url":"One_question_per_day/338. 比特位计数.html","title":"338. 比特位计数","keywords":"","body":"2021-3-3338. 比特位计数思路2021-3-3 338. 比特位计数 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为$O(n*sizeof(integer))$的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为$O(n)$。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/counting-bits 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：暴力算法直接计算 我们使用暴力算法解答出属于[0,num]之间每个数二进制中1的个数。 时间复杂度：$O(n\\times sizeof(int))$ 空间复杂度：$O(1)$ 代码 class Solution { public: vector countBits(int num) { vector ans; for (int i = 0; i >= 1; } return sum; } }; 方法2：动态规划-最高有效位 $i\\&(i - 1)$表示最低位的1所表示的 方法一需要对每个数遍历其二进制表示的每一位。可以换一个思路，当计算 i的「一比特数」时，如果存在$ 0 \\le j 令 $\\textit{bits}[i]$ 表示 i 的「一比特数」，则上述关系可以表示成：$\\textit{bits}[i]= \\textit{bits}[j]+1$。 对于正整数 x，如果可以知道最大的正整数 y，使得 $y \\le x$且 y是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，此时称 y 为 x 的「最高有效位」。令$ z=x-y$，显然 $0 \\le z 为了判断一个正整数是不是 2 的整数次幂，可以利用方法一中提到的按位与运算的性质。如果正整数 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，因此 $y \\&(y-1)=0$。由此可见，正整数 y 是 2的整数次幂，当且仅当 $y \\&(y-1)=0$。 显然，0的「一比特数」为 0。使用 $\\textit{highBit}$表示当前的最高有效位，遍历从 1 到 $\\textit{num}$ 的每个正整数 i，进行如下操作。 如果 $i \\&(i-1)=0$，则令 $\\textit{highBit}=i$，更新当前的最高有效位。 i 比 $i-\\textit{highBit}$ 的「一比特数」多 1，由于是从小到大遍历每个数，因此遍历到 i时，$i-\\textit{highBit}$ 的「一比特数」已知，令$ \\textit{bits}[i]=\\textit{bits}[i-\\textit{highBit}]+1$。 最终得到的数组 $\\textit{bits}$ 即为答案。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 class Solution { public: vector countBits(int num) { vector ans(num + 1); int high; for (int i = 1; i 方法3：动态规划-最低有效位 方法二需要实时维护最高有效位，当遍历到的数是 2的整数次幂时，需要更新最高有效位。如果再换一个思路，可以使用「最低有效位」计算「一比特数」。 对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 $\\lfloor \\frac{x}{2} \\rfloor$。如果 $\\textit{bits}\\big[\\lfloor \\frac{x}{2} \\rfloor\\big]$的值已知，则可以得到 $\\textit{bits}[x]$的值： 如果 x是偶数，则$ \\textit{bits}[x]=\\textit{bits}\\big[\\lfloor \\frac{x}{2} \\rfloor\\big]$ 如果 x 是奇数，则$ \\textit{bits}[x]=\\textit{bits}\\big[\\lfloor \\frac{x}{2} \\rfloor\\big]+1$。 上述两种情况可以合并成：$\\textit{bits}[x]$的值等于 $\\textit{bits}\\big[\\lfloor \\frac{x}{2} \\rfloor\\big]$的值加上 x 除以 2 的余数。 由于 $\\lfloor \\frac{x}{2} \\rfloor$可以通过 x >> 1 得到，x 除以 2 的余数可以通过 x \\& 1 得到，因此有：$\\textit{bits}[x]=\\textit{bits}[x>>1]+(x \\& 1)$。 遍历从 1到 $\\textit{num}$的每个正整数 i，计算 $\\textit{bits}$ 的值。最终得到的数组 $\\textit{bits}$ 即为答案。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 class Solution { public: vector countBits(int num) { vector ans(num + 1); for (int i = 1; i > 1] + (i & 1); } return ans; } }; 方法4：动态规划——最低设置位 定义正整数 x的「最低设置位」为 x 的二进制表示中的最低的 1 所在位。例如，1010 的二进制表示是 ，其最低设置位为 2，对应的二进制表示是 $10_{(2)}$ 。 令 $y=x \\&(x-1)$，则 y 为将 x 的最低设置位从 1 变成 0 之后的数，显然 $0 \\le y 遍历从 1 到 $\\textit{num}$的每个正整数 i，计算 $\\textit{bits}$的值。最终得到的数组$ \\textit{bits}$ 即为答案。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 class Solution { public: vector countBits(int num) { vector ans(num + 1); for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/34. 在排序数组中查找元素的第一个和最后一个位置.html":{"url":"One_question_per_day/34. 在排序数组中查找元素的第一个和最后一个位置.html","title":"34. 在排序数组中查找元素的第一个和最后一个位置","keywords":"","body":"2020-12-134. 在排序数组中查找元素的第一个和最后一个位置思路2020-12-1 不知不觉就到了今年的最后一月了，前路漫漫，继续加油 34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 -109 nums 是一个非递减数组 -109 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：二分查找 该题是一个典型的二分查找问题，我们首先找到数组中最后一个小于等于目标值的下标，然后再找到数组中第一个大于等于目标值的下标。那么答案就是这两个下标的区间，返回即可。 对于找不到有以下几种可能 1.数组为空 2.数组中下标为0的值大于目标值 3.数组中没有等于目标值的值 对于前面两种，我们可以通过特判，这样就减少了搜索的时间。 废话不多说上代码 代码 class Solution { public: vector searchRange(vector& nums, int target) { if (!nums.size()) { return {-1,-1}; } if (nums[0] > target) { return {-1, -1}; } int l1 = 0, r1 = nums.size() - 1, l2 = 0; while (l1 > 1; if (nums[mid] > 1; if (nums[mid] >= target) { r2 = mid; }else { l2 = mid + 1; } } return {r2, l1}; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/354. 俄罗斯套娃信封问题.html":{"url":"One_question_per_day/354. 俄罗斯套娃信封问题.html","title":"354. 俄罗斯套娃信封问题","keywords":"","body":"2021-3-4354. 俄罗斯套娃信封问题思路2021-3-4 354. 俄罗斯套娃信封问题 给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 说明: 不允许旋转信封。 示例: 输入: envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/russian-doll-envelopes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划（暴力） 本题是一个二维的问题（高度和宽度），为了解题方便我们可以将它简化成一维的，如何简化呢？ 我们可以将数组按宽度排序，这样我们可以不用再管宽度这个变量了，某个下标的宽度一定不小于它前面所有下标的宽度。 如果宽度相等的话，我们就按高度从大到小的顺序排，因为宽度相等，所以它们不能嵌套，我们状态转移时是根据当前坐标的前面坐标的高度是否小于当前坐标的高度来转移的，如果小于则可以转移，否则不能转移，但是宽度相等的本来就不能转移，所以我们将高度较大的排到前面就不需要多余的判断了。 排序完后，我们遍历数组进行动态规划。递推公式如下。 $dp[i] = max(dp[i],dp[j] + 1) (0 然后取最大的$dp[i]$，即为我们的答案。 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$，$dp$数组所需空间。 代码 class Solution { public: int maxEnvelopes(vector>& envelopes) { int ans = 0; int n = envelopes.size(); vector dp(n + 5); auto cmp = [&](vector &a, vector &b) {return a[0] b[1]);}; sort(envelopes.begin(), envelopes.end(), cmp); for (int i = 0; i 方法2：动态规划（二分查找） 该方法不好细说！！！ 时间复杂度：$O(nlogn)$，利用二分查找优化查找过程为$logn$ 空间复杂度：$O(n)$，$dp$所需空间 代码 class Solution { public: int maxEnvelopes(vector>& envelopes) { int ans = 0; int n = envelopes.size(); vector dp(n + 5, 0); auto cmp = [&](vector &a, vector &b) {return a[0] b[1]);}; sort(envelopes.begin(), envelopes.end(), cmp); vector num(n + 5, 0); for (int i = 1; i &num, int l, int r, int x) { while (l > 1; if (num[mid] By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/376. 摆动序列.html":{"url":"One_question_per_day/376. 摆动序列.html","title":"376. 摆动序列","keywords":"","body":"2020-12-12376. 摆动序列思路2020-12-12 376. 摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1: 输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。 示例 2: 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3: 输入: [1,2,3,4,5,6,7,8,9] 输出: 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/wiggle-subsequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划（二维数组） 首先是自己的思路，比较笨，但是感觉好理解 利用一个二维数组，dp[i][3],第一维为以数组小标为i结尾的序列的长度，第二维总共有0,1,2三种情况，代表的是以数组中第i个数结束，它是以什么情况结束的。是以不是升序也不是降序，还是以升序，又或者以降序结束。 然后我利用两层循环，第一层循环分别统计倒数第二个数是以0 - n-1的情况，再第二层循环计算，最后一个数为第一层循环的后面的数。 每次计算都记录一个最大值。 时间复杂度：O(n^2) 空间复杂度“：O(n) 太菜了，可能解释的不是很清楚，直接看代码理解吧。 代码 class Solution { public: int dp[1000000][3] = {0}; int wiggleMaxLength(vector& nums) { int ans = 1; if (nums.empty()) { return 0; } if (nums.size() nums[i]) { dp[j][2] = max(dp[i][1] + 1, dp[j][2]); ans = max(ans, dp[j][2]); }else if (nums[j] 方法二：贪心算法（官方解答） 观察这个序列可以发现，我们不断地交错选择「峰」与「谷」，可以使得该序列尽可能长。证明非常简单：如果我们选择了一个「过渡元素」，那么在原序列中，这个「过渡元素」的两侧有一个「峰」和一个「谷」。不失一般性，我们假设在原序列中的出现顺序为「峰」「过渡元素」「谷」。如果「过渡元素」在选择的序列中小于其两侧的元素，那么「谷」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「谷」；同理，如果「过渡元素」在选择的序列中大于其两侧的元素，那么「峰」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「峰」。这样一来，我们总可以将任意满足要求的序列中的所有「过渡元素」替换成「峰」或「谷」。并且由于我们不断地交错选择「峰」与「谷」的方法就可以满足要求，因此这种选择方法就一定可以达到可选元素数量的最大值。 这样，我们只需要统计该序列中「峰」与「谷」的数量即可（注意序列两端的数也是「峰」或「谷」），但需要注意处理相邻的相同元素。 在实际代码中，我们记录当前序列的上升下降趋势。每次加入一个新元素时，用新的上升下降趋势与之前对比，如果出现了「峰」或「谷」，答案加一，并更新当前序列的上升下降趋势。 代码 class Solution { public: int wiggleMaxLength(vector& nums) { int n = nums.size(); if (n 0 && prevdiff = 0)) { ret++; prevdiff = diff; } } return ret; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/387. 字符串中的第一个唯一字符.html":{"url":"One_question_per_day/387. 字符串中的第一个唯一字符.html","title":"387. 字符串中的第一个唯一字符","keywords":"","body":"2020-12-23387. 字符串中的第一个唯一字符思路2020-12-23 387. 字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： s = \"leetcode\" 返回 0 s = \"loveleetcode\" 返回 2 提示：你可以假定该字符串只包含小写字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希表 利用一个数组代替哈希表，将字符串中每个字符的个数记录下来，然后再次遍历数组，找到第一个字符次数为1的字符，返回下标即可，如果遍历完所有字符都没找到，返回-1。 时间复杂度:O(n)，遍历两边字符串 代码 class Solution { public: int num[137] = {0}; int firstUniqChar(string s) { for (auto &i : s) { num[i]++; } for (int i = 0 ; s[i]; ++i) { if (num[s[i]] == 1) { return i; } } return -1; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/389. 找不同.html":{"url":"One_question_per_day/389. 找不同.html","title":"389. 找不同","keywords":"","body":"2020-12-18389. 找不同思路2020-12-18 389. 找不同 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例 1： 输入：s = \"abcd\", t = \"abcde\" 输出：\"e\" 解释：'e' 是那个被添加的字母。 示例 2： 输入：s = \"\", t = \"y\" 输出：\"y\" 示例 3： 输入：s = \"a\", t = \"aa\" 输出：\"a\" 示例 4： 输入：s = \"ae\", t = \"aea\" 输出：\"a\" 提示： 0 t.length == s.length + 1 s 和 t 只包含小写字母 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-the-difference 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希表 利用哈希表先记录在s中出现的字符的个数，然后t中没遇到一个字符，就将该字符在哈希表中映射到的值减一，当该值为负数时，说明该字符串就是答案，返回即可。 时间复杂度：O(n)，遍历s和t字符串 空间复杂度：O(字符集)，最多需要存储26个小写字母的映射。 代码 class Solution { public: char findTheDifference(string s, string t) { unordered_map mmap; for (auto &i : s) { mmap[i]++; } for (auto &i : t) { if (mmap[i]) { mmap[i]--; continue; } return i; } return '\\0'; } }; 方法2：求和 将s字符串中所有字符的ASCII相加得到一个和sum1，将t字符串中所有字符的ASCII相加得到一个和sum2，因为t字符串和s字符串只相差一个字符，所以最终答案返回ASCII码（sum2-sum1）所对应的字符即可。 时间复杂度：O(n) 空间复杂度：O(1) 代码 class Solution { public: char findTheDifference(string s, string t) { int sum1 = 0, sum2 = 0; for (auto &i : s) { sum1 += i; } for (auto &i : t) { sum2 += i; } return sum2 - sum1; } }; 方法3：位运算 对于两个字符串中，只有最终答案那个字符串才出现过奇数次，这和我们找唯一一个不同的数类似，对两个字符串全体异或，最终得到答案。 时间复杂度：O(n) 空间复杂度：O(1) 代码 class Solution { public: char findTheDifference(string s, string t) { char ans = 0; for (auto &i : s) { ans ^= i; } for (auto &i : t) { ans ^= i; } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/395. 至少有K个重复字符的最长子串.html":{"url":"One_question_per_day/395. 至少有K个重复字符的最长子串.html","title":"395. 至少有K个重复字符的最长子串","keywords":"","body":"2021-2-27395. 至少有K个重复字符的最长子串思路2021-2-27 395. 至少有K个重复字符的最长子串 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 示例 1： 输入：s = \"aaabb\", k = 3 输出：3 解释：最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。 示例 2： 输入：s = \"ababbc\", k = 2 输出：5 解释：最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。 提示： $1 $s仅由小写英文字母组成$ $1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：分治 借鉴的官方解答，作为记录！！ 链接如下: 对于字符串 s，如果存在某个字符 $\\textit{ch}$，它的出现次数大于 0 且小于 k，则任何包含 $\\textit{ch}$ 的子串都不可能满足要求。也就是说，我们将字符串按照 $\\textit{ch}$ 切分成若干段，则满足要求的最长子串一定出现在某个被切分的段内，而不能跨越一个或多个段。因此，可以考虑分治的方式求解本题。 复杂度分析 时间复杂度：$O(N\\cdot |\\Sigma|)$，其中 N 为字符串的长度，$\\Sigma$ 为字符集，本题中字符串仅包含小写字母，因此$ |\\Sigma|$ = 26。由于每次递归调用都会完全去除某个字符，因此递归深度最多为 $|\\Sigma|$。 空间复杂度：$O(|\\Sigma|^2)$。递归的深度为 $O(|\\Sigma|)$，每层递归需要开辟 $O(|\\Sigma|)$的额外空间。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/zhi-shao-you-kge-zhong-fu-zi-fu-de-zui-c-o6ww/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 class Solution { public: int dfs(const string& s, int l, int r, int k) { vector cnt(26, 0); for (int i = l; i 0 && cnt[i] r) { break; } int start = i; while (i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/399. 除法求值.html":{"url":"One_question_per_day/399. 除法求值.html","title":"399. 除法求值","keywords":"","body":"2021-1-6399. 除法求值思路2021-1-6 399. 除法求值 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi =values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。 注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。 示例 1： 输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]] 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000] 解释： 条件：a / b = 2.0, b / c = 3.0 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 结果：[6.0, 0.5, -1.0, 1.0, -1.0 ] 示例 2： 输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]] 输出：[3.75000,0.40000,5.00000,0.20000] 示例 3： 输入：equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]] 输出：[0.50000,2.00000,-1.00000,-1.00000] 提示： 1 equations[i].length == 2 1 values.length == equations.length 0.0 1 queries[i].length == 2 1 Ai, Bi, Cj, Dj 由小写英文字母与数字组成 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/evaluate-division 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：并查集 该方法解释比较抽象，直接上代码把。可自行去查找并查集相关内容 时间复杂度：$O(nlogn)$,对于每个结点去查找它的祖先节点所需$logn$,总共n个节点 空间复杂度：$O(n)$，为每个节点保存相应的信息 代码 class Solution { public: unordered_map > mmap; unordered_map mmap1; vector calcEquation(vector>& equations, vector& values, vector>& queries) { vector ans; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/424. 替换后的最长重复字符.html":{"url":"One_question_per_day/424. 替换后的最长重复字符.html","title":"424. 替换后的最长重复字符","keywords":"","body":"2021-2-2424. 替换后的最长重复字符思路2021-2-2 标签: $滑动窗口$，$双指针$ 424. 替换后的最长重复字符 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意：字符串长度 和 k 不会超过 104。 示例 1： 输入：s = \"ABAB\", k = 2 输出：4 解释：用两个'A'替换为两个'B',反之亦然。 示例 2： 输入：s = \"AABABBA\", k = 1 输出：4 解释： 将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。 子串 \"BBBB\" 有最长重复字母, 答案为 4。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-repeating-character-replacement 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：滑动窗口+双指针 我们可以枚举字符串中的每一个位置作为右端点，然后找到其最远的左端点的位置，满足该区间内除了出现次数最多的那一类字符之外剩余的字符（即非最长重复字符）数量不超过 k个。 这样我们可以想到使用双指针维护这些区间，每次右指针右移，如果区间仍然满足条件，那么左指针不移动，否则左指针至多右移一格，保证区间长度不减小。 虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了 k个。但是这样的区间也同样不可能对答案产生贡献。当我们右指针移动到尽头，左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。 实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 26的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，然后尝试用它更新重复字符出现次数的历史最大值，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可。 借的官方解答：链接如下 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-n6aza/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：$O(n)$，扫描一遍即可。 空间复杂度：$O(|\\sum|)$，其中$|\\sum|$是字符集的大小，我们需要存储每个大写字母出现的次数。 代码 class Solution { public: int characterReplacement(string s, int k) { vector num(26); int n = s.length(); int maxn = 0; int left = 0, right = 0; while (right k) { num[s[left] - 'A']--; left++; } right++; } return right - left; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/435. 无重叠区间.html":{"url":"One_question_per_day/435. 无重叠区间.html","title":"435. 无重叠区间","keywords":"","body":"2020-12-31435. 无重叠区间思路2020-12-31 435. 无重叠区间 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-overlapping-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：排序+贪心 本题我们使用multimap来进行排序，排序方法是根据每个区间的起点的大小进行排序，起点大小越小越靠前。 排序完后，我们就可以开始遍历multimap，我们遍历过程中，要记录上一个区间的终点$end$（初始值设置为排序后的第一个区间的起点)。 遍历方法如下 每次遍历，判断当前区间的起点是否大于等于上一个区间的终点，如果大于，将$end$修改为当前区间的终点，开始遍历下一个区间 如果当前区间的起点小于$end$，说明当前区间与上一个区间有重叠，我们将答案加一(从两个区间中选择一个区间移除)，我们选择哪个区间移除呢？我们当然要从这两个区间中选择终点小的那个区间，这就是我们的贪心思想，只有前面的终点越小，后面才能尽量不重叠。然后将$end$,改为这个较小的终点值即可。然后遍历下一个区间。 为什么我们只需要判断当前区间的起点与上个区间的终点大小即可呢？这就是我们为什么要将区间按起点大小排序的原因，因为对于每个区间它的终点一定是大于起点的，然后起点又是从小到大排序的，当我们遍历到当前区间时，说明上个区间与上上个区间是没有重叠的，假设这两个区间为$(x1,y1),(x2,y2)$,那么满足这样的条件$x2=x1>=y2$, 只是$x和y1的关系不能确定，但是x和y2的关系是确定的，所以不管去除当前区间还是上个区间，都是满足和上上个区间没有重叠的。$ 最终遍历完整个map后，返回答案即可 时间复杂度:$O(nlogn)$，主要是插入到map的时间消耗，每次插入需要logn的时间复杂度，插入了n次 空间复杂度:$O(n)$,需要保存n个区间。 代码 class Solution { public: int eraseOverlapIntervals(vector>& intervals) { int ans = 0; if (intervals.empty() || intervals.size() == 1) { return 0; } multimap mmap; int size = 0; for (auto &i : intervals) { mmap.insert(multimap::value_type(i[0],i[1])); } int end = mmap.begin()->first; for (auto &i : mmap) { if (i.first By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/452. 用最少数量的箭引爆气球.html":{"url":"One_question_per_day/452. 用最少数量的箭引爆气球.html","title":"452. 用最少数量的箭引爆气球","keywords":"","body":"2020-11-23452. 用最少数量的箭引爆气球思路2020-11-23 452. 用最少数量的箭引爆气球 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4： 输入：points = [[1,2]] 输出：1 示例 5： 输入：points = [[2,3],[2,3]] 输出：1 提示： 0 points[i].length == 2 -231 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：利用multimap进行排序 本题是一个关于贪心算法的题，我们需要使用合理的贪心算法来解决它。 首先我们来判断题意，箭的坐标必须大于等于气球的起始坐标小于等于气球的结束坐标时，才能将气球击破。 所以为了尽量用少的箭，我们的箭必须尽量击破多的气球。 怎样才能实现这样的要求呢？我们可以根据气球的结束坐标的大小将气球进行排队，然后将我们的第一把箭放在第一个气球 的结束坐标上，这样既能击破我们的第一个气球，又能尽可能的多的击破后面的气球，只要后面的气球的起始坐标，小于该把箭的坐标即可。当碰到气球起始坐标大于该把箭的坐标时，我们就可能需要第二把箭了，同样也是放在这个气球的结束坐标，依次类推，直到遍历完所有的气球，就能得到我们的答案了。 代码 class Solution { public: int findMinArrowShots(vector>& points) { if (points.empty()) { return 0; } int ans = 1; multimap mmap; for (int i = 0; i ::value_type(points[i][1],points[i][0])); } int min = mmap.begin() -> first; for (auto i : mmap) { if (i.second By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/454. 四数相加 II.html":{"url":"One_question_per_day/454. 四数相加 II.html","title":"454. 四数相加 II","keywords":"","body":"2020-11-27454. 四数相加 II思路2020-11-27 454. 四数相加 II 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/4sum-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 例如: 输入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出: 2 解释: 两个元组如下: 1.(0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2.(1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/4sum-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希表 我们将四个数组两两分组，然后用一个哈希表，记录第一组中两个数组中的数的和的所有可能，然后遍历第二组，如果0减去第二组两个数的和，该值在哈希表存在，就将答案加1。 思路比较简单，就不细讲了。 代码 class Solution { public: int fourSumCount(vector& A, vector& B, vector& C, vector& D) { if (A.empty()) { return 0; } int ans = 0; unordered_map mmap; for (auto &i : A) { for (auto &j : B) { mmap[i + j]++; } } for (auto &i : C) { for (auto &j : D) { ans += mmap[-i - j]; } } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/455. 分发饼干.html":{"url":"One_question_per_day/455. 分发饼干.html","title":"455. 分发饼干","keywords":"","body":"2020-12-25455. 分发饼干思路2020-12-25 圣诞快乐 455. 分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示： 1 0 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/assign-cookies 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：排序+贪心 为了尽可能满足多的孩子，我们需要利用尽可能小的饼干去满足每个孩子，所以我们将孩子的胃口值以及饼干尺寸进行排序。利用双指针，依次遍历孩子的胃口值和饼干尺寸数组。当饼干尺寸大于等于孩子的胃口值时，答案加一，两个指针都往后走一位，如果小于则找到第一个大于等于该胃口值的，然后将这块饼干分配给该小朋友，两个指针往后走一位。如果遍历完整个饼干尺寸数组都没找到大于等于该胃口值的饼干尺寸，则退出遍历，返回答案，结束程序即可。 时间复杂度：$O(glogg+slogs)$，主要是对两个数组进行排序 空间复杂度：$O(logg + logs)$，排序所占的空间复杂度（快排或者归并排序） 代码 class Solution { public: int findContentChildren(vector& g, vector& s) { int ans = 0; if (g.empty() || s.empty()) { return ans; } sort(g.begin(), g.end()); sort(s.begin(), s.end()); int l = 0; for (auto &i : g) { while ( l = i) { ans++; l++; } if (l == s.size()) break; } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/48. 旋转图像.html":{"url":"One_question_per_day/48. 旋转图像.html","title":"48. 旋转图像","keywords":"","body":"2020-12-1948. 旋转图像思路2020-12-19 48. 旋转图像 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotate-image 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：队列 我们用队列来存储翻转后的矩阵顺序，最终从队列中取出值即可。 方法比较简单，就不细讲了。 时间复杂度：O(n^2) 空间复杂度：O(n^2) 代码 class Solution { public: void rotate(vector>& matrix) { queue que; for (int i = 0; i = 0 ; --j) { que.push(matrix[j][i]); } } for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/49. 字母异位词分组.html":{"url":"One_question_per_day/49. 字母异位词分组.html","title":"49. 字母异位词分组","keywords":"","body":"2020-12-1449. 字母异位词分组思路2020-12-14 49. 字母异位词分组 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/group-anagrams 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：排序+哈希 对于该题我们可以对每组字母异位词，利用一个标准来区分，然后通过这个标准，在哈希表中找到它的同类。 那我们定一个什么标准呢，我们可以将每个字符串进行排序，然后利用排序后的字符串作为标准，这样来只有同为一组字母异位词的字符串，对应的标准才有可能相同 然后利用这个标准去哈希表中查找对应的组，插入到这个组即可。 时间复杂度：O(nmlogm)，m为最长字符串的长度（所以排序的时间复杂度为mlogm），n为字符串个数，有m个字符串需要排序。 空间复杂度：O(nk)，利用哈希表维护n个字符，k为字符串中最长的那个的长度 代码如下： 代码 class Solution { public: vector> groupAnagrams(vector& strs) { vector > ans(strs.size()); if (strs.empty()) { return ans; } int cnt = 0; unordered_map mmap; for (auto &i : strs) { string str = i; string str1 = i; sort(str1.begin(),str1.end()); if (mmap[str1] == 0) { ans[cnt++].push_back(str); mmap[str1] = cnt; }else { ans[mmap[str1] - 1].push_back(str); } } return {ans.begin(), ans.begin() + cnt}; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/503. 下一个更大元素 II.html":{"url":"One_question_per_day/503. 下一个更大元素 II.html","title":"503. 下一个更大元素 II","keywords":"","body":"2021-3-6503. 下一个更大元素 II思路2021-3-6 要点：将数组拉直达到循环数组的效果. 503. 下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 注意: 输入数组的长度不会超过 10000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/next-greater-element-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：暴力搜索 对于每个下标我们都往后面搜索第一个比它大的元素，如果能搜到则压入答案，不能则压入-1，这是一种纯暴力的解法，对于数组长度较大的数据量则会超时 时间复杂度：$O(n^2)$。 空间复杂度：$O(1)$。 代码 class Solution { public: vector nextGreaterElements(vector& nums) { vector ans; for (int i = 0; i nums[i]) { flag = 1; ans.push_back(nums[j]); break; } } if (!flag) ans.push_back(-1); } return ans; } }; 方法2：单调栈+循环数组 思路及算法 我们可以使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组 $\\textit{nums}$中对应的值是单调不升的。 每次我们移动到数组中的一个新的位置 i，我们就将当前单调栈中所有对应值小于$\\textit{nums}[i]$ 的下标弹出单调栈，这些值的下一个更大元素即为$\\textit{nums}[i]$证明很简单：如果有更靠前的更大元素，那么这些位置将被提前弹出栈）。随后我们将位置 i入栈。 但是注意到只遍历一次序列是不够的，例如序列$ [2,3,1]$，最后单调栈中将剩余$ [3,1]$，其中元素$ [1]$的下一个更大元素还是不知道的。 一个朴素的思想是，我们可以把这个循环数组「拉直」，即复制该序列的前 $n-1$个元素拼接在原序列的后面。这样我们就可以将这个 新序列当作普通序列，用上文的方法来处理。 而在本题中，我们不需要显性地将该循环数组「拉直」，而只需要在处理时对下标取模即可。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/next-greater-element-ii/solution/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$，栈空间 代码 class Solution { public: typedef pair P11; vector nextGreaterElements(vector& nums) { int n = nums.size(); vector ans(n, -1); stack stk; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/509. 斐波那契数.html":{"url":"One_question_per_day/509. 斐波那契数.html","title":"509. 斐波那契数","keywords":"","body":"2021-1-4509. 斐波那契数思路2021-1-4 509. 斐波那契数 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你 n ，请计算 F(n) 。 示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fibonacci-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递推 使用一个递推数组，对于下标为i的值，由如下公式推导 $dp[i]=dp[i-1]+dp=2\">i-2,dp[0]=0,dp[1]=1$ 根据这个公式我们i从2开始往后推到n，得出$dp[n]$,则是我们的最终答案。 时间复杂度：$O(n)$,从2遍历到n 代码 class Solution { public: int dp[35] = {0, 1}; int fib(int n) { for (int i = 2; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/547. 省份数量.html":{"url":"One_question_per_day/547. 省份数量.html","title":"547. 省份数量","keywords":"","body":"2021-1-7547. 省份数量思路2021-1-7 547. 省份数量 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不 接相连。 返回矩阵中 省份 的数量。 示例 1： 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]] 输出：2 示例 2： 输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]] 输出：3 提示： 1 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-provinces 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：深度优先搜索 该方法是比较常规的方法，我们遍历一遍矩阵isConnected，如果$isConnected[i][j]==1$，我们就将答案加一，因为这个结点为1表示i和j是同一个区域，然后对$j$进行深搜点进行深搜，将与$j$点连通的点都划分为一个区域，这些点也必与$i$点相连通。 值得注意的是，我们进行深搜时，应该进行去重，去重方法如下。 当我们遍历到$i和j$相连通时，应该将$isConnected[i][j]以及isConnected[j][i]都置为0$，表示遍历过了。 时间复杂度：$O(n^2)$,需要遍历矩阵 空间复杂度：$O(n)$,递归深度最多遍历n个城市。 代码 class Solution { public: int n; int findCircleNum(vector>& isConnected) { int ans = 0; n = isConnected.size(); for (int i = 0; i >&visited, int ind) { for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/561. 数组拆分 I.html":{"url":"One_question_per_day/561. 数组拆分 I.html","title":"561. 数组拆分 I","keywords":"","body":"2021-2-16(正月初五)561. 数组拆分 I思路2021-2-16(正月初五) 561. 数组拆分 I 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。 返回该 最大总和 。 示例 1： 输入：nums = [1,4,3,2] 输出：4 解释：所有可能的分法（忽略元素顺序）为： (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3 (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3 (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4 所以最大的和为4 示例 2: 输入：nums = [6,2,6,5,1,2] 输出：9 解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9 提示： $1 $nums.length == 2 * n$ $-10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/array-partition-i 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：排序 本题对于每一对我们都是从中选取较小的值作为我们答案的一部分，为了使我们的答案最大，我们要使我们选取出来了几个数的和最大。所以我们应该将较小的绑在一起，将较大的绑在一起。因为如果我们将较大的和较小的绑在一起，那么我们只会选择这个较小的，这个较大的就不可能作为我们答案的一部分。所以本题的解题思路很简单，我们先排序，然后$i$从数组的0号下标开始遍历，每次$i=i+2$，表示取下一对中的较小值，将取出来的数加起来的和就是我们的答案。 时间复杂度：$O(nlogn)$,排序所需要的时间复杂度。 空间复杂度：$O(logn)$,排序所需要的栈空间。 代码 class Solution { public: int arrayPairSum(vector& nums) { int ans = 0; sort(nums.begin(), nums.end()); for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/566. 重塑矩阵.html":{"url":"One_question_per_day/566. 重塑矩阵.html","title":"566. 重塑矩阵","keywords":"","body":"2021-2-17（正月初六)566. 重塑矩阵思路2021-2-17（正月初六) 566. 重塑矩阵 难度简单172 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 输入: nums = [[1,2], [3,4]] r = 1, c = 4 输出: [[1,2,3,4]] 解释: 行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 输入: nums = [[1,2], [3,4]] r = 2, c = 4 输出: [[1,2], [3,4]] 解释: 没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 思路 方法1:模拟 本题模拟即可就不细说了，具体看代码。 代码中也有小技巧 %以及/的灵活运用 代码 class Solution { public: vector> matrixReshape(vector>& nums, int r, int c) { if (nums.size() * nums[0].size() != r * c) { return nums; } vector > ans(r, vector(c)); for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/567. 字符串的排列.html":{"url":"One_question_per_day/567. 字符串的排列.html","title":"567. 字符串的排列","keywords":"","body":"2021-2-10567. 字符串的排列思路2021-2-10 567. 字符串的排列 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 输入: s1 = \"ab\" s2 = \"eidbaooo\" 输出: True 解释: s2 包含 s1 的排列之一 (\"ba\"). 示例2: 输入: s1= \"ab\" s2 = \"eidboaoo\" 输出: False 注意： 输入的字符串只包含小写字母 $两个字符串的长度都在 [1, 10,000] 之间$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutation-in-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：双指针+哈希表+滑动窗口 本题我们首先使用一个哈希表$mmap$来存储s1字符串的所有字符以及每个字符出现的次数，然后s1字符串长度记为$n$。 然后利用一个左指针$l$，以及一个右指针$i$，每次我们的右指针$i$往后移动，然后利用哈希表$mmap1$记录它遍历过的字符以及出现的次数，当$i-l==n$，说明这时s2中左指针$l$到右指针$i$之间的子串(不包含$i$指针所对应的字符串)长度和s1字符串的长度相同，这时我们判断一下这个子串是否属于s1字符串的排列字符串。如果是返回$true$，即可。 如果不是，我们需要将左指针往后移动一个单位，然后将$mmap1[s2[l]]--$，表示将$l$这个指针所对应的字符移出这个我们维护的子串。然后$r$右指针再往后移动判断即可。这样我们相当于维护的一个没有退路的滑动窗口。遍历一遍字符串即可。 值得注意的是，对于右指针$r$,遍历到s2字符串的末尾时，我们没有进行判断，这时我们需要多加一条判断即可。 时间复杂度：$O(m\\times{n}-n^2)$，m是s2的长度，n是s1的长度。每次我们需要$O(n)$时间复杂度的判断。需要判断$m-n$次。 空间复杂度：$O(n)$，n是s1的长度，需要两个哈希表维护两个长度为n的字符串。 代码 class Solution { public: unordered_map mmap; unordered_map mmap1; bool checkInclusion(string s1, string s2) { int n = s1.size(), l = 0; for (auto &i : s1) { mmap[i]++; } for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/605. 种花问题.html":{"url":"One_question_per_day/605. 种花问题.html","title":"605. 种花问题","keywords":"","body":"2021-1-1605. 种花问题思路2021-1-1 首先新年快乐，Leetcode真良心，新年第一天出简单！！！ 605. 种花问题 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1 输出: True 示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2 输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/can-place-flowers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：贪心+模拟 使用ans记录可以种多少花 我们遍历一遍数组，当某个下标的值为0时，有如下情况 当下标为$0$时，我们只需要判断下标为1的值是否为1，如果为1，则不能种花，往下遍历，如果为0则可以种花，将$flowerbed[0]$置为1，表示在下标为0的地方可以种花，ans加一。 当下标$i$为$[1,flowerbed.size()-1)$时，我们需要判断该下标的前一个值和后一个值是否为0，只有这两个条件都满足时才能种花，ans加1,$flowedbed[i]=1$。 当下标$i$为$flowerbed.size()-1$,此时我们只需判断前一个下标的值是否为0即可，为0的话，直接将ans加一即可。 值得注意的几个点是 当我们数组长度为1时，有如下几点 当n为0时，直接返回true 当n大于1时，直接返回false 当n为1时，判断这个数组中这个唯一的值是0还是1，是0的话返回true，否则返回false 当我们遍历到某个下标时，ans已经大于等于n了，则可以直接返回true，如果遍历完数组都没有返回true，返回false。 时间复杂度：$O(n)$,遍历一遍数组即可 空间复杂度：$O(1)$,不需要额外的空间 代码 class Solution { public: bool canPlaceFlowers(vector& flowerbed, int n) { int ans =0 ; if (flowerbed.size() == 1) { if (flowerbed[0] == 1) { return n == 0 ? true : false; }else { return n > 1 ? false : true; } } for (int i = 0; i = n) return true; } return false; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/62. 不同路径.html":{"url":"One_question_per_day/62. 不同路径.html","title":"62. 不同路径","keywords":"","body":"2020-12-0962. 不同路径思路2020-12-09 62. 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 向右 -> 向右 -> 向下 向右 -> 向下 -> 向右 向下 -> 向右 -> 向右 示例 2: 输入: m = 7, n = 3 输出: 28 提示： 1 题目数据保证答案小于等于 2 * 10 ^ 9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划，递推 本题是一个经典的动态规划题，我们对于每个点可以从左边到达，也可以从上面到达， 所以很容易建立以下递推式： dp[m][n] = dp[m-1][n] + dp[m][n - 1] 值得注意的是，我们的递推边界是，地图的最上边，以及地图的最左边，路径数都只有一种。 有了边界和递推式，我们就可以开始写我们的代码了。 代码 class Solution { public: int dp[100][100] = {0}; int uniquePaths(int m, int n) { dp[0][0] = 1; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/628. 三个数的最大乘积.html":{"url":"One_question_per_day/628. 三个数的最大乘积.html","title":"628. 三个数的最大乘积","keywords":"","body":"2021-1-20628. 三个数的最大乘积思路2021-1-20 628. 三个数的最大乘积 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 输入: [1,2,3] 输出: 6 示例 2: 输入: [1,2,3,4] 输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-three-numbers 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：排序+模拟 我们首先遍历一遍数组，将负数和正数以及0分别存起来，然后分类别讨论即可。 思路较简单，就不细说了，直接看代码吧 代码 class Solution { public: int maximumProduct(vector& nums) { int ans = 1; vector temp1; vector temp2; int zero = 0; for (auto &i : nums) { if (i == 0) { zero = 1; }else if (i > 0) { temp1.push_back(i); }else { temp2.push_back(i); } } sort(temp1.begin(), temp1.end()); sort(temp2.begin(), temp2.end()); int n = temp1.size(); int m = temp2.size(); if (temp2.size() = 3) { ans = temp1[n-1] * temp1[n - 2] * temp1[n - 3]; }else if (zero){ ans = 0; }else { ans = temp1[n - 1] * temp1[n - 2] * temp2[0]; } }else { if (temp1.size() == 0) { if (zero) { ans = 0; }else { ans = temp2[m - 1] * temp2[m - 2] * temp2[m - 3]; } }else if (temp1.size() = 3) { if (temp2[0] * temp2[1] > temp1[n - 2] * temp1[n - 3]) { ans = temp2[0] * temp2[1] * temp1[n - 1]; }else { ans = temp1[n - 1] * temp1[n - 2] * temp1[n - 3]; } } } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/649. Dota2 参议院.html":{"url":"One_question_per_day/649. Dota2 参议院.html","title":"649. Dota2 参议院","keywords":"","body":"2020-12-11649. Dota2 参议院思路2020-12-11 649. Dota2 参议院 Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇) Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项： 禁止一名参议员的权利： 参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。 宣布胜利： 如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。 给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给字符串的大小将是 n。 以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过中被跳过。 假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输 出应该是 Radiant 或 Dire。 示例 1： 输入：\"RD\" 输出：\"Radiant\" 解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任 权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人 示例 2： 输入：\"RDD\" 输出：\"Dire\" 解释： 第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利 第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止 第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利 因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dota2-senate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：贪心模拟+栈 本题我们可以用栈来进行模拟，先记录每个阵营成员的个数，然后遍历字符串，对于入栈出栈操作如下。 我们利用一个循环，当每个阵营成员个数都大于0时，满足循环条件，进入循环。 在循环中，我们遍历我们的字符串。 下面就是我们的入栈出栈操作 1.当栈为空时，如果遍历到的字符为'D'或者'R',直接将该字符入栈。 2.栈不为空时，我们需要考虑两种情况 ​ a.栈顶元素与遍历到的元素相同，直接入栈即可。 ​ b.栈顶元素与遍历到的元素不同，将字符串中遍历到的相应的元素改为'0',表示下次不再遍历该元素（出局了），将遍历到的元素所属 阵营的成员个数减一，将栈顶元素出栈。 在循环中当我们判断到某个阵营成员个数为0的时候，退出循环。 然后根据阵营剩余成员个数的大小来判断哪个阵营获胜。 代码如下： 代码 class Solution { public: string predictPartyVictory(string senate) { unordered_map mmap; for (int i = senate.size() - 1; i >= 0; --i) { mmap[senate[i]]++; } stack stk; while (mmap['R'] != 0 && mmap['D'] != 0 ) { for (auto &i : senate) { if (i != '0' && stk.empty()) { stk.push(i); }else if (i == 'R' || i == 'D'){ if (i == stk.top()) { stk.push(i); }else { mmap[i]--; i = '0'; stk.pop(); } } if (mmap['R'] == 0 || mmap['D'] == 0) break; } } if (mmap['R'] == 0) return \"Dire\"; return \"Radiant\"; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/665. 非递减数列.html":{"url":"One_question_per_day/665. 非递减数列.html","title":"665. 非递减数列","keywords":"","body":"2021-2-7665. 非递减数列思路2021-2-7 665. 非递减数列 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 示例 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明： $1 $10 ^ 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/non-decreasing-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：循环+记录 本题标签是简单题，但是细看不太简单，挺有意思的一道题。 我们循环遍历数组，对于每个坐标的元素值小于前一个坐标的元素值时，我们做如下判断，假设当前坐标为$i$。 判断$i-2$坐标的元素值是否小于等于$i$坐标的元素值，如果是的话，将$i-1$坐标的元素值修改为$i-2$坐标的元素值，表示在$i-1$坐标做一次修改即可使这个$i$坐标插入进来形成非递减数列。如果不是的话，我们就需要将$i$坐标的元素值修改为$i-1$坐标的元素值，使得其等于$i-1$坐标的元素值。这两种不同情况的策略都是为了贪心的使$i$坐标的值最小化，以至于后续能有更多的元素加入这个维护的非递减数列。 当我们的修改次数大于等于2时，直接返沪$flase$,表示一次修改不能使整个数组达到非递减数列。退出循环后返回$true$即可。 对于$i==1$,的情况，当$i=1$坐标的元素小于$i-1=0$坐标的元素时，我们只需要将修改次数加1即可。因为这里只有一种情况，就是将$i-1$的坐标元素修改为$i$坐标元素即可。 时间复杂度：$O(n)$，遍历一遍数组即可。 空间复杂度：$O(1)$，没有额外的空间消耗。 代码 class Solution { public: bool checkPossibility(vector& nums) { int flag = 0; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/674. 最长连续递增序列.html":{"url":"One_question_per_day/674. 最长连续递增序列.html","title":"674. 最长连续递增序列","keywords":"","body":"2021-1-24674. 最长连续递增序列思路2021-1-24 674. 最长连续递增序列 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 提示： $0 $-10^9 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：循环加记录 我们使用一个中间变量$temp$来保存数组中的所有连续递增序列，然后取其中最大的赋值给$ans$即可。 方法如下： 当我们遍历到值比它前面的值大时，将$temp++$。 当我们遍历到的值比它前面的值小时，就从$temp$和$ans$中取较大的值给$ans$,然后将$temp$赋值为1,表示从这个下标往后重新开始计算长度 值得注意的是，我们的最后一个值可能比倒数第二个值大，所以在最后不会将$temp$和$ans$进行比较，我们只需要在最后比较一次即可。 时间复杂度：$O(n)$，遍历一遍数组即可。 空间复杂度：$O(1)$，不需要额外的空间。 代码 class Solution { public: int findLengthOfLCIS(vector& nums) { if (nums.empty()) { return 0; } int ans = 1; int temp = 1; for (int i = 1; i nums[i - 1]) { temp++; }else { ans = max(ans, temp); temp = 1; } } ans = max(ans,temp); return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/684. 冗余连接.html":{"url":"One_question_per_day/684. 冗余连接.html","title":"684. 冗余连接","keywords":"","body":"2021-1-13684. 冗余连接思路2021-1-13 684. 冗余连接 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这 附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满 相同的格式 u 示例 1： 输入: [[1,2], [1,3], [2,3]] 输出: [2,3] 解释: 给定的无向图为 1 / \\ 2 - 3 示例 2： 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]] 输出: [1,4] 解释: 给定的无向图为: 5 - 1 - 2 ​ | | ​ 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/redundant-connection 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：并查集 突然发现LeetCode现在好喜欢出并查集的题目。 本题也是一个典型的连通性集合问题，所以我们就可以用并查集来做，并查集思想就不解释了。 我们遍历一遍数组，然后将遍历到的两个点进行合并，合并成一个集合。 在合并前我们需要判断这两个点是否已经在一个集合中了，如果在的话，说明就不需要合并，这两个点之间的边就是我们的答案。返回即可。 时间复杂度：$O(n\\log{n})$，遍历数组，每次合并需要$\\log{n}$的时间复杂度 空间复杂度：$O(n)$，需要保存每个点的集合信息。 代码 class Solution { public: int color[10000]; int n; vector findRedundantConnection(vector>& edges) { n = edges.size(); for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/697. 数组的度.html":{"url":"One_question_per_day/697. 数组的度.html","title":"697. 数组的度","keywords":"","body":"2021-2-20（正月初九）697. 数组的度思路2021-2-20（正月初九） 697. 数组的度 给定一个非空且只包含非负数的整数数组 nums，数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1： 输入：[1, 2, 2, 3, 1] 输出：2 解释： 输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2. 示例 2： 输入：[1,2,2,3,1,4,2] 输出：6 提示： $nums.length在1到50,000区间范围内。$ $nums[i] 是一个在 0 到 49999 范围内的整数。$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/degree-of-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：双指针 本题我们先计算出原数组的度，然后利用两个指针来计算与 nums 拥有相同大小的度的最短连续子数组。具体方法如下： 首先将我们的左右指针$l$以及$i$初始化为0，然后右指针$i$往后开始遍历，每次遍历都将遍历到的下标所对应的数值出现的次数加1，当我们遍历到某个数值出现的次数等于$nums$的度时，说明$l$到$i$之间的子数组的度和原数组的度相同。 上一步完成后，我们还需要往后移动$l$,直到$nums[l]==nums[i]$,才停止，因为我们这个子数组中是以$nums[i]$出现的次数作为度的，那么我们可以将这个子数组中第一个$nums[i]$出现的下标前面的数值抛弃掉，这样可以减小我们的子数组长度，使答案最小化。 移动$l$时，我们需要将每次$l$移动前$nums[l]$出现的次数减去1，表示后续这个下标的数用不到了。 时间复杂度：$O(n)$,遍历两遍数组即可。 空间复杂度：$O(n)$,最多存储数组中每一个数组出现的次数。 代码 class Solution { public: int cnt[100000] = {0}; int findShortestSubArray(vector& nums) { int mmax = 0; int ans = INT32_MAX; for (auto &i : nums) { cnt[i]++; mmax = max(mmax, cnt[i]); } memset(cnt, 0, sizeof(cnt)); int l = 0; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/703. 数据流中的第 K 大元素.html":{"url":"One_question_per_day/703. 数据流中的第 K 大元素.html","title":"703. 数据流中的第 K 大元素","keywords":"","body":"2021-2-11703. 数据流中的第 K 大元素思路2021-2-11 首先祝大家除夕快乐！！！ 703. 数据流中的第 K 大元素 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。 请实现 KthLargest 类： KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。 示例： 输入： [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"] [[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] 输出： [null, 4, 5, 5, 8, 8] 解释： KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 提示： $1 $0 $-10^4 $-10^4 最多调用 add 方法 $10^4$ 次 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-a-stream 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：二叉搜索树+size。 本题是一个典型的topk问题，这里我使用一个带有size的二叉搜索树来实现。通过判断每个节点的左右子树size和k的大小，我们就可以判断去左子树查找还是去右子树查找了。这里就不细说了。 代码 class Node{ public: int val; Node *lchild, *rchild; int size; Node(int val); Node(){ val = 0; lchild = rchild = nullptr; size = 0; } void insert(int val); void output(); int topk(int k); }; Node _NIL; Node *NIL = &_NIL; Node::Node(int val) { this->val = val; this->lchild = this->rchild = NIL; this->size = 1; } void Node::insert(int val){ if (this->val > val) { if (lchild == NIL) lchild = new Node(val); else lchild->insert(val); }else if (this->val insert(val); } this->size = lchild->size + rchild->size + 1; } void Node::output() { if (lchild != NIL) { lchild->output(); } printf(\"%d\\n\",this->val); if (rchild != NIL) { rchild->output(); } return; } int Node::topk(int k) { if (rchild->size == k - 1) { return val; }else if (rchild->size topk(k - rchild->size - 1); }else { return rchild->topk(k); } } class tree{ private: Node *root; public: tree(){ root = NIL; } void insert(int val) { if (root == NIL) { root = new Node(val); }else { root->insert(val); } } void output() { if (root == NIL) return; root->output(); } int topk(int k) { if (root == NIL) return 0; return root->topk(k); } }; class KthLargest { public: tree tr; int k; KthLargest(int k, vector& nums) { this->k = k; for (auto &i : nums) { tr.insert(i); } //tr.output(); } int add(int val) { tr.insert(val); return tr.topk(k); return 0; } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj->add(val); */ 方法2：固定大小的小顶堆 我们使用一个大小为k的堆来维护，堆顶则是我们的第k大元素。每次堆的元素个数为k时，再插入进来元素时，我们要做如下判断。 插入进来的元素是否大于堆顶元素，如果小于等于则不需要进行插入。 如果大于则需要将堆顶元素移出堆，将该元素插入即可。表示这个元素插入进来后，它(堆顶元素）后面已经有k个元素比它大了，它不可能是第k大元素了。 时间复杂度：$O(n\\times{logk})$，每次插入需要$O(logk)$，n为初始化时$nums$的长度。 空间复杂度：$O(k)$，需要维护k大小的堆。 代码 class KthLargest { public: int k; priority_queue, greater> que; KthLargest(int k, vector& nums) { this->k = k; for (auto i : nums) { if (que.size() add(val); */ By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/714. 买卖股票的最佳时机含手续费.html":{"url":"One_question_per_day/714. 买卖股票的最佳时机含手续费.html","title":"714. 买卖股票的最佳时机含手续费","keywords":"","body":"2020-12-17714. 买卖股票的最佳时机含手续费思路2020-12-17 714. 买卖股票的最佳时机含手续费 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划（官方解答，这里借鉴，动态规划还不是很熟） 考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。 定义状态 dp[i][0] 表示第 i天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i天交易完后手里持有一支股票的最大利润（i从0 开始）。 考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i-1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i-1][1]，这时候我们要将其卖出，并获得 prices[i]的收益，但需要支付 fee 的手续费。因此为了收益最大化，我们列出如下的转移方程： dp[i][0]=max{dp[i-1][0],dp[i-1][1]+prices[i]-fee}; 再来按照同样的方式考虑 dp[i][1]按状态转移，那么可能的转移状态为前一天已经持有一支股票，即dp[i-1][1]，或者前一天结束时还没有股票，即dp[i-1][0]，这时候我们要将其买入，并减少 prices[i]的收益。可以列出如下的转移方程： dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]} 对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候有 dp[0][0]=0 以及 dp[0][1]= -prices[0]. 因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n-1][1] 的，最后的答案即为dp[n-1][0]。 代码（官方解答，这里记录） class Solution { public: int maxProfit(vector& prices, int fee) { int n = prices.size(); vector > dp(n, vector(2)); dp[0][0] = 0, dp[0][1] = -prices[0]; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/721. 账户合并.html":{"url":"One_question_per_day/721. 账户合并.html","title":"721. 账户合并","keywords":"","body":"2021-1-18721. 账户合并思路2021-1-18 721. 账户合并 给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 示该账户的邮箱地址。 现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同 名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的 称。 合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。 示例 1： 输入： accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.c m\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]] 输出： [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"m y@mail.com\"]] 解释： 第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 \"johnsmith@mail.com\"。 第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。 可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']， ['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。 提示： accounts的长度将在[1，1000]的范围内。 accounts[i]的长度将在[1，10]的范围内。 accounts[i][j]的长度将在[1，30]的范围内。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/accounts-merge 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:并查集 本题我们使用并查集来完成，对于属于同一类集和的元素，它们具有拥有相同邮箱的特点，我们每次遍历每个用户的邮箱，如果它的邮箱在前面的用户出现过，就将这两个用户归为一类集和，merge即可。merge完后，为了方便计算我们还需遍历一遍，将它们之间进行路径压缩。 最后我们就可以开始将属于同一集和的元素归并起来并返回答案了。值得注意的如下： 对于每个用户我们的邮箱应该从下到大进行排序，并且不能有重复，所以我们可以使用set集和来先进行保存，最后遍历这个集和即可。 我们的用户名可能有重复，所以我们不能用它来唯一标识每个用户，应该用在$accounts$数组中的下标来标识用户。 基于以上几点，这样我们就完成了该题。 代码 class Solution { public: int color[1005] = {0}; int size[1005] = {0}; vector> accountsMerge(vector>& accounts) { vector> ans; if (accounts.empty()) { return {}; } unordered_map mmap; unordered_map> mmap1; for (int i = 0 ; i temp; temp.push_back(accounts[i.first][0]); for (auto &j : i.second) { temp.push_back(j); } ans.push_back(temp); } return ans; } int update(int x) { if (color[x] == x) { return x; }else { return color[x] = update(color[x]); } } void merge(int x, int y) { int temp1 = update(x); int temp2 = update(y); color[temp1] = temp2; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/724. 寻找数组的中心索引.html":{"url":"One_question_per_day/724. 寻找数组的中心索引.html","title":"724. 寻找数组的中心索引","keywords":"","body":"2021-1-28724. 寻找数组的中心索引思路2021-1-28 724. 寻找数组的中心索引 给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。 我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1： 输入： nums = [1, 7, 3, 6, 5, 6] 输出：3 解释： 索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。 同时, 3 也是第一个符合要求的中心索引。 示例 2： 输入： nums = [1, 2, 3] 输出：-1 解释： 数组中不存在满足此条件的中心索引。 说明： nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-pivot-index 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：前缀和 我们利用一个前缀和数组$sum$来保存前n项的和，然后对于每个索引$i$我们判断它前面所有数字的和$sum[i - 1]$和它后面所有数字的和$sum[n(数组的长度)]-sum[i-1]$是否相等。如果相等我们返回$i-1$（$sum$下标从1开始存，$nums$下标从0开始存，所以要减去1）。 如果遍历完所有索引都没有发现使它前后相等的索引，最后返回$-1$即可。 时间复杂度：$O(n)$，遍历一遍数组即可。 空间复杂度：$O(n)$，保存每个索引的前缀和。 代码 class Solution { public: int sum[10005] = {0}; int pivotIndex(vector& nums) { for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/738. 单调递增的数字.html":{"url":"One_question_per_day/738. 单调递增的数字.html","title":"738. 单调递增的数字","keywords":"","body":"2020-12-15738. 单调递增的数字思路2020-12-15 738. 单调递增的数字 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。 （当且仅当每个相邻位数上的数字 x 和 y 满足 x 示例 1: 输入: N = 10 输出: 9 示例 2: 输入: N = 1234 输出: 1234 示例 3: 输入: N = 332 输出: 299 说明: N 是在 [0, 10^9] 范围内的一个整数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/monotone-increasing-digits 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：贪心算法 我们首先用一个vector记录N的每一位数字,遍历这个vector，寻找第一个后一个数字比前一个数字小的下标，如果没有直接返回N即可，因为原本给我们的数字就是单调递增了。 找到这个下标后，然后将下标前一个数字减去1（这时我们就要遍历这个下标所有的前面的数字了，因为减去1了，所以可能导致前面的也不满足了，找到最后一个不满足条件的下标记录下来）。然后再次遍历数组，当遍历到我们记录的那个下标后时，将后面的数字全部置为9，这样会使整体数字最大。 时间复杂度：O(logN),表示N的位数 空间复杂度：O(logN)，存储N的每一位 代码如下： class Solution { public: int monotoneIncreasingDigits(int N) { int ans = 0, flag = 0, cnt = 0, temp = N; vector num; if (N == 0) { return ans; } while (temp) { num.push_back(temp % 10); temp /= 10; } reverse(num.begin(), num.end()); if (num.size() == 1) { return num[0]; } for (int i = 1; i = num[i - 1]) { if (i == num.size() - 1) { flag = 1; } }else { int j = i; flag = 1; while (j >= 1 && num[j] cnt) { ans = ans * 10 + 9; }else { ans = ans * 10 + num[i]; } } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/746. 使用最小花费爬楼梯.html":{"url":"One_question_per_day/746. 使用最小花费爬楼梯.html","title":"746. 使用最小花费爬楼梯","keywords":"","body":"2020-12-21746. 使用最小花费爬楼梯思路2020-12-21 746. 使用最小花费爬楼梯 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划 对于每一层楼梯i我们可以从i-1和i-2层上来，我们从这两种方法中，选择花费最小的方法，在加上本层的花费，就可达到局部最优，为了方便我们应该在cost数组最后放一个0，表示顶层。递推公式如下： $$ dp[i]=min(dp[i],dp[i-1])+cost[i] $$ 因为可以从第一层或者第零层开始，所以递推边界为dp[0],dp[1]. 我们从dp[2],开始往后推导即可。 时间复杂度：O(n)，遍历一遍数组即可 空间复杂度：O(n)，存储每个点的相应状态。 代码 class Solution { public: int dp[1005] = {0}; int minCostClimbingStairs(vector& cost) { dp[0] = cost[0]; dp[1] = cost[1]; cost.push_back(0); for (int i = 2; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/767. 重构字符串.html":{"url":"One_question_per_day/767. 重构字符串.html","title":"767. 重构字符串","keywords":"","body":"2020-11-30767. 重构字符串思路2020-11-30 767. 重构字符串 给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。 若可行，输出任意可行的结果。若不可行，返回空字符串。 示例 1: 输入: S = \"aab\" 输出: \"aba\" 示例 2: 输入: S = \"aaab\" 输出: \"\" 注意: S 只包含小写字母并且长度在[1, 500]区间内。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reorganize-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 这道题是典型的贪心算法的题。重构字符串时，需要根据每个字母在字符串中出现的次数处理每个字母放置的位置。如果出现次数最多的字母可以在重新排布之后不相邻，则可以重新排布字母使得相邻的字母都不相同。如果出现次数最多的字母过多，则无法重新排布字母使得相邻的字母都不相同。 假设字符串的长度为 n，如果可以重新排布成相邻的字母都不相同的字符串，每个字母最多出现多少次？ 当 n是偶数时，有 n/2个偶数下标和 n/2个奇数下标，因此每个字母的出现次数都不能超过 n/2次，否则出现次数最多的字母一定会出现相邻。 当 n 是奇数时，由于共有 (n+1)/2个偶数下标，因此每个字母的出现次数都不能超过 (n+1)/2次，否则出现次数最多的字母一定会出现相邻。 由于当 n 是偶数时，在整数除法下满足 n/2 和 (n+1)/2相等，因此可以合并 n 是偶数与 n 是奇数的情况：如果可以重新排布成相邻的字母都不相同的字符串，每个字母最多出现 (n+1)/2 次。 因此首先遍历字符串并统计每个字母的出现次数，如果存在一个字母的出现次数大于 (n+1)/2，则无法重新排布字母使得相邻的字母都不相同，返回空字符串。如果所有字母的出现次数都不超过 (n+1)/2，则考虑如何重新排布字母。 方法1：最大堆 维护最大堆存储字母，堆顶元素为出现次数最多的字母。首先统计每个字母的出现次数，然后将出现次数大于 0的字母加入最大堆。 当最大堆的元素个数大于 1时，每次从最大堆取出两个字母，拼接到重构的字符串，然后将两个字母的出现次数分别减 1，并将剩余出现次数大于 0的字母重新加入最大堆。由于最大堆中的元素都是不同的，因此取出的两个字母一定也是不同的，将两个不同的字母拼接到重构的字符串，可以确保相邻的字母都不相同。 如果最大堆变成空，则已经完成字符串的重构。如果最大堆剩下 1 个元素，则取出最后一个字母，拼接到重构的字符串。 对于长度为 n的字符串，共有 n/2次每次从最大堆取出两个字母的操作，当 n是奇数时，还有一次从最大堆取出一个字母的操作，因此重构的字符串的长度一定是 n。 当 n是奇数时，是否可能出现重构的字符串的最后两个字母相同的情况？如果最后一个字母在整个字符串中至少出现了 2 次，则在最后一次从最大堆取出两个字母时，该字母会先被选出，因此不会成为重构的字符串的倒数第二个字母，也不可能出现重构的字符串最后两个字母相同的情况。 因此，在重构字符串可行的情况下，基于最大堆的贪心算法可以确保得到正确答案。 代码 class Solution { public: struct node { char c; int number; bool operator number (S.size() + 1)/2 ) return \"\"; priority_queue que; for (int i = 0 ; i 0) { que.push(num[i]); } } string ans = \"\"; while (que.size() > 1) { node l1 = que.top(); que.pop(); node l2 = que.top(); que.pop(); ans += l1.c; ans += l2.c; l1.number--; l2.number--; if (l1.number) que.push(l1); if (l2.number) que.push(l2); } if (que.size() > 0) ans += que.top().c; return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/778. 水位上升的泳池中游泳.html":{"url":"One_question_per_day/778. 水位上升的泳池中游泳.html","title":"778. 水位上升的泳池中游泳","keywords":"","body":"2021-1-30778. 水位上升的泳池中游泳思路2021-1-30 前记：看到是困难题，本以为会很难，仔细看题这不是昨日的每日一题变种嘛。 778. 水位上升的泳池中游泳 在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。 现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。 你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？ 示例 1: 输入: [[0,2],[1,3]] 输出: 3 解释: 时间为0时，你位于坐标方格的位置为 (0, 0)。 此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。 等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中 任意位置 示例2: 输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] 输出: 16 解释: 最终的路线用加粗进行了标记。 我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示: $2 $grid[i][j]是[0, ..., N*N - 1] 的排列。$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/swim-in-rising-water 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：BFS+优先队列 本题与昨日那题是一类题如下： 解题思路如下： https://github.com/longkejie/Leetcode/blob/main/One_question_per_day/1631.%20%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.md 只是把我们昨日的状态中的高度差，改为时间即可，然后每次遍历更新时间是取两者时间的最大值。 这里就不细说了，可直接看代码 代码 class Solution { public: struct node { int x, y; int time; }; int mark[55][55] = {0}; int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1}; int swimInWater(vector>& grid) { int ans = INT32_MAX; int n = grid.size(); auto cmp = [&](node &a, node &b) {return a.time > b.time;}; priority_queue,decltype(cmp)> que(cmp); que.push(node{0,0,grid[0][0]}); while (que.size()) { node temp = que.top(); que.pop(); mark[temp.x][temp.y] = 1; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/830. 较大分组的位置.html":{"url":"One_question_per_day/830. 较大分组的位置.html","title":"830. 较大分组的位置","keywords":"","body":"2021-1-5830. 较大分组的位置思路2021-1-5 830. 较大分组的位置 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = \"abbxxxxzyy\" 中，就含有 \"a\", \"bb\", \"xxxx\", \"z\" 和 \"yy\" 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 \"xxxx\" 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。 示例 1： 输入：s = \"abbxxxxzzy\" 输出：[[3,6]] 解释：\"xxxx\" 是一个起始于 3 且终止于 6 的较大分组。 示例 2： 输入：s = \"abc\" 输出：[] 解释：\"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。 示例 3： 输入：s = \"abcdddeeeeaabbbcd\" 输出：[[3,5],[6,9],[12,14]] 解释：较大分组为 \"ddd\", \"eeee\" 和 \"bbb\" 示例 4： 输入：s = \"aba\" 输出：[] 提示： 1 s 仅含小写英文字母 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/positions-of-large-groups 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：循环 本题较为简单，使用几个中间变量保存结果即可，就不多阐述了 代码 class Solution { public: vector> largeGroupPositions(string s) { if (s.size() > ans; int start = 0; int length = 1; for (int i = 1; i = 3) { ans.push_back({start, i - 1}); } length = 1; start = i; } } if (length >= 3) { ans.push_back({start, (int)(s.size()-1)}); } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/839. 相似字符串组.html":{"url":"One_question_per_day/839. 相似字符串组.html","title":"839. 相似字符串组","keywords":"","body":"2021-1-31839. 相似字符串组思路2021-1-31 前记：2021一月的最后一天，不出所料还是并查集。正式结束了并查集月。 839. 相似字符串组 如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。 例如，\"tars\" 和 \"rats\" 是相似的 (交换 0 与 2 的位置)； \"rats\" 和 \"arts\" 也是相似的，但是 \"star\" 不与 \"tars\"，\"rats\"，或 \"arts\" 相似。 总之，它们通过相似性形成了两个关联组：{\"tars\", \"rats\", \"arts\"} 和 {\"star\"}。注意，\"tars\" 和 \"arts\" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。 给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？ 示例 1： 输入：strs = [\"tars\",\"rats\",\"arts\",\"star\"] 输出：2 示例 2： 输入：strs = [\"omv\",\"ovm\"] 输出：1 提示： $1 $1 $sum(strs[i].length) $strs[i]只包含小写字母。$ $strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。$ 备注： 字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/similar-string-groups 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：并查集 这题是一道困难题，其实并不困难，对于是否相似的两个字符串我们只要判断两个字符串对应的下标的字符不同的数量是否超过2即可 我还以为有什么特别的判断方法呢。 我们利用循环遍历数组中每个下标的字符串是否与它前面的某个字符串属于相似字符串，如果是的话利用并查集标记为同一个集和即可。 最后我们判断一下并查集中集和的个数，即为我们的答案，至此我们就完成了这道困难题。 时间复杂度：$O(n^2m + n \\log n))$其中 nn 是字符串的数量。我们需要$O(n^2)$地枚举任意一对字符串之间的关系，对于任意一对字符串，我们需要$ O(m)$的时间检查字符串是否相同。在最坏情况下我们需要对并查集执行 $O(n)$次合并，合并的均摊时间复杂度 $O(\\log n)$。综上，总的时间复杂度为 $O(n^2m + n \\log n))$ 空间复杂度：$O(n)$，保存并查集集和信息。 代码 class Solution { public: int color[1005] = {0}; bool check(string x, string y) { int num = 0; for (int i = 0; i 2) return false; } return true; } int numSimilarGroups(vector& strs) { int ans = 0; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/842. 将数组拆分成斐波那契序列.html":{"url":"One_question_per_day/842. 将数组拆分成斐波那契序列.html","title":"842. 将数组拆分成斐波那契序列","keywords":"","body":"2020-12-08842. 将数组拆分成斐波那契序列思路2020-12-08 842. 将数组拆分成斐波那契序列 给定一个数字字符串 S，比如 S = \"123456579\"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。 形式上，斐波那契式序列是一个非负整数列表 F，且满足： 0 F.length >= 3； 对于所有的0 另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。 返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。 示例 1： 输入：\"123456579\" 输出：[123,456,579] 示例 2： 输入: \"11235813\" 输出: [1,1,2,3,5,8,13] 示例 3： 输入: \"112358130\" 输出: [] 解释: 这项任务无法完成。 示例 4： 输入：\"0123\" 输出：[] 解释：每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。 示例 5： 输入: \"1101111\" 输出: [110, 1, 111] 解释: 输出 [11,0,11,11] 也同样被接受。 提示： 1 字符串 S 中只含有数字。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 搬的官方的解答，自己写了一份代码，但超时了，可能太粗糙了，这里借鉴一下官方的。 方法1：回溯 + 剪枝 将给定的字符串拆分成斐波那契式序列，可以通过回溯的方法实现。 使用列表存储拆分出的数，回溯过程中维护该列表的元素，列表初始为空。遍历字符串的所有可能的前缀，作为当前被拆分出的数，然后对剩余部分继续拆分，直到整个字符串拆分完毕。 根据斐波那契式序列的要求，从第 33个数开始，每个数都等于前 2 个数的和，因此从第 3 个数开始，需要判断拆分出的数是否等于前 2个数的和，只有满足要求时才进行拆分，否则不进行拆分。 回溯过程中，还有三处可以进行剪枝操作。 拆分出的数如果不是 0，则不能以 0 开头，因此如果字符串剩下的部分以 0 开头，就不需要考虑拆分出长度大于 1 的数，因为长度大于 1 的数以 0 开头是不符合要求的，不可能继续拆分得到斐波那契式序列； 拆分出的数必须符合 32 位有符号整数类型，即每个数必须在 [0,2^{31}-1][0,2 31 −1] 的范围内，如果拆分出的数大于 2^{31}-1 ，则不符合要求，长度更大的数的数值也一定更大，一定也大于 2^{31}-1，因此不可能继续拆分得到斐波那契式序列； 如果列表中至少有 2个数，并且拆分出的数已经大于最后 2个数的和，就不需要继续尝试拆分了。 当整个字符串拆分完毕时，如果列表中至少有 3个数，则得到一个符合要求的斐波那契式序列，返回列表。如果没有找到符合要求的斐波那契式序列，则返回空列表。 实现方面，回溯需要带返回值，表示是否存在符合要求的斐波那契式序列。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/jiang-shu-zu-chai-fen-cheng-fei-bo-na-qi-ts6c/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 class Solution { public: vector splitIntoFibonacci(string S) { vector list; backtrack(list, S, S.length(), 0, 0, 0); return list; } bool backtrack(vector& list, string S, int length, int index, long long sum, int prev) { if (index == length) { return list.size() >= 3; } long long curr = 0; for (int i = index; i index && S[index] == '0') { break; } curr = curr * 10 + S[i] - '0'; if (curr > INT_MAX) { break; } if (list.size() >= 2) { if (curr sum) { break; } } list.push_back(curr); if (backtrack(list, S, length, i + 1, prev + curr, curr)) { return true; } list.pop_back(); } return false; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/86. 分隔链表.html":{"url":"One_question_per_day/86. 分隔链表.html","title":"86. 分隔链表","keywords":"","body":"2021-1-386. 分隔链表思路2021-1-3 86. 分隔链表 给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例： 输入：head = 1->4->3->2->5->2, x = 3 输出：1->2->2->4->3->5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/partition-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：循环模拟 我们设置两个虚拟头结点$head1,head2$，然后开始遍历链表，每次判断链表中该节点的val值小于x还是大于等于x，如果小于x，在$head1$对应的链表中插入一个新节点，它的值为链表中该节点的值，否则在$head2$对应的链表中插入。 为什么要建立新节点？ 避免在链表中形成环 避免出现指针乱指的情况 时间复杂度：$O(n)$，遍历一遍链表 空间复杂度：$O(n)$，需要新的链表对原链表复制一遍。 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { ListNode *head1 = new ListNode(-1); ListNode *temp1 = head1; ListNode *head2 = new ListNode(-1); ListNode *temp2 = head2; ListNode *p = head; while (p != NULL) { if (p -> val next = new ListNode(p->val); temp1 = temp1 -> next; }else { temp2 -> next =new ListNode(p->val); temp2 = temp2 -> next; } p = p -> next; } temp1 -> next = head2 -> next; temp2 -> next = NULL; return head1 -> next; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/860. 柠檬水找零.html":{"url":"One_question_per_day/860. 柠檬水找零.html","title":"860. 柠檬水找零","keywords":"","body":"2020-12-10860. 柠檬水找零思路2020-12-10 860. 柠檬水找零 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1： 输入：[5,5,5,10,20 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 输入：[5,5,10] 输出：true 示例 3： 输入：[10,10] 输出：false 示例 4： 输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 0 bills[i] 不是 5 就是 10 或是 20 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lemonade-change 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：贪心算法 本题是一道关于贪心的题目，每次我们收到买柠檬水的钱是5,10或者20块，我们可以分别对这三种情况进行讨论 1.收到5块钱 不需要找零，我们可以收到自己的兜里，直接将自己拥有的5元零钱数加一即可。 2.收到10块钱 我们需要找零五块钱，往自己兜里摸摸看有没有五块钱的零钱，有的话找出去，五元零钱数减一，十元零钱数加一。如果没有五元的零钱可找，就直接返回false结束程序 3.收到20块钱 我们需要找零十五元钱，这时我们有两种方法，一种是找一张十元的和一张五元的，一种是找三张五元的。对于这两种方法，我们肯定是倾向于前者，因为我们的五元钱对于找零来说，比我们的十元钱更有用，所以我们先来判断我们有没有十元钱的零钱，如果有的话，执行第一种方法，没有的话执行第二种方法，这两种方法都不能完成找零的话，就返回false结束程序。 但我们所有的都能完成找零，则返回true 接下来我们就可以代码演示上述过程了 代码 class Solution { public: bool lemonadeChange(vector& bills) { if (bills.empty()) { return true; } unordered_map mmap; for (auto i : bills) { if (i == 5) { mmap[i]++; }else if (i == 10) { if (mmap[5] == 0) { return false; }else { mmap[5]--; mmap[i]++; } }else if (i == 20) { if (mmap[10] > 0) { if (mmap[5]) { mmap[5]--; mmap[10]--; }else { return false; } }else { if (mmap[5] >= 3) { mmap[5] -= 3; }else { return false; } } } } return true; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/861. 翻转矩阵后的得分.html":{"url":"One_question_per_day/861. 翻转矩阵后的得分.html","title":"861. 翻转矩阵后的得分","keywords":"","body":"2020-12-07861. 翻转矩阵后的得分思路2020-12-07 861. 翻转矩阵后的得分 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。 示例： 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]] 输出：39 解释： 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]] 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/score-after-flipping-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 提示： 1 1 A[i][j] 是 0 或 1 思路 方法1：贪心算法 本题是一个关于贪心的算法，首先我们判断每一行是否应该进行移动，判断的标准是最高位是0还是1（数组的下标0），如果是0的话，我们翻转后肯定会将整体的数值变大，这由二进制的性质可得，反之，则不翻转。 对于行翻转完后，我们再来翻转每一列，判断标准则是，计算每一列中0的个数和1的个数，因为它们在二进制中的位置是相同的，所以只要0的个数比1的个数多，我们就要进行翻转，这样就会将整体的数值增大，反之，则不翻转。 下面上代码（第一版的代码，挺粗糙的） 代码 class Solution { public: int matrixScore(vector>& A) { if (A.empty()) { return 0; } for (int i = 0; i = 0; --j) { if (A[i][j] == 1) { temp1 += 1 temp1) { for (int j = 0; j = cnt0) continue; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/947. 移除最多的同行或同列石头.html":{"url":"One_question_per_day/947. 移除最多的同行或同列石头.html","title":"947. 移除最多的同行或同列石头","keywords":"","body":"2021-1-15947. 移除最多的同行或同列石头思路2021-1-15 947. 移除最多的同行或同列石头 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。 示例 1： 输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] 输出：5 解释：一种移除 5 块石头的方法如下所示： 移除石头 [2,2] ，因为它和 [2,1] 同行。 移除石头 [2,1] ，因为它和 [0,1] 同列。 移除石头 [1,2] ，因为它和 [1,0] 同行。 移除石头 [1,0] ，因为它和 [0,0] 同列。 移除石头 [0,1] ，因为它和 [0,0] 同行。 石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。 示例 2： 输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] 输出：3 解释：一种移除 3 块石头的方法如下所示： 移除石头 [2,2] ，因为它和 [2,0] 同行。 移除石头 [2,0] ，因为它和 [0,0] 同列。 移除石头 [0,2] ，因为它和 [0,0] 同行。 石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。 示例 3： 输入：stones = [[0,0]] 输出：0 解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。 提示： 1 0 不会有两块石头放在同一个坐标点上 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：深度优先搜索 本题我们使用深度优先搜索来做，对于每个点我们需要根据该点尽量多移除石头，假设将这些石头的坐标连接成一条路径，那么我们就需要走到底，这正是我们深度优先搜索的思想。 时间复杂度：$O(n^2)$，每个点都被遍历一次，每次需要$O(n)$判断是否有点和该点在同一列或者同一行。 空间复杂度：$O(n)$，需要一个标记数组来记录某点是否被访问过，递归的深度最多也是$O(n)$。 代码 class Solution { public: unordered_map> mark; int removeStones(vector>& stones) { int ans = 0; if (stones.size() > &stones) { for (auto &i : stones) { if (mark[i[0]][i[1]]) continue; if (i[0] == x || i[1] == y) { mark[i[0]][i[1]] = 1; ans++; dfs(i[0], i[1], ans, stones); } } return ; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/978. 最长湍流子数组.html":{"url":"One_question_per_day/978. 最长湍流子数组.html","title":"978. 最长湍流子数组","keywords":"","body":"2021-2-8978. 最长湍流子数组思路2021-2-8 978. 最长湍流子数组 当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组： 若 i A[k+1]，且当 k 为偶数时，A[k] 或 若 i A[k+1] ，且当 k 为奇数时， A[k] 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。 返回 A 的最大湍流子数组的长度。 示例 1： 输入：[9,4,2,10,7,8,8,1,9] 输出：5 解释：(A[1] > A[2] A[4] 示例 2： 输入：[4,8,12,16] 输出：2 示例 3： 输入：[100] 输出：1 提示： $1 $0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-turbulent-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：双指针+差分数组 本题不细写了直接看代码吧。 代码 class Solution { public: vector num; int maxTurbulenceSize(vector& arr) { int ans = 0; if (arr.size() = 0) { ans = max(ans, i + 1 - l + 1); l = i + 1; } } if (num[l] == 0) l++; ans = max(ans, n - l + 1); return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"One_question_per_day/989. 数组形式的整数加法.html":{"url":"One_question_per_day/989. 数组形式的整数加法.html","title":"989. 数组形式的整数加法","keywords":"","body":"2021-1-22989. 数组形式的整数加法思路2021-1-22 989. 数组形式的整数加法 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 1： 输入：A = [1,2,0,0], K = 34 输出：[1,2,3,4] 解释：1200 + 34 = 1234 示例 2： 输入：A = [2,7,4], K = 181 输出：[4,5,5] 解释：274 + 181 = 455 示例 3： 输入：A = [2,1,5], K = 806 输出：[1,0,2,1] 解释：215 + 806 = 1021 示例 4： 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1 输出：[1,0,0,0,0,0,0,0,0,0,0] 解释：9999999999 + 1 = 10000000000 提示： 1 0 0 如果 A.length > 1，那么 A[0] != 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:大整数加法 我们可以套用大整数加法的模板解法，我们使用两个大数组(大小为10005)，所有位都是0(这样可以避免越界和多余的判断)。然后将数组A以及K所代表的值分别给两个大数组赋值，数组的低位存整数的低位，这样我们进位的时候更加方便，然后将这两个大数组一一对应相加。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 具体我们看代码 代码 class Solution { public: int num1[10005] = {0}, num2[10005] = {0}; vector addToArrayForm(vector& A, int K) { vector ans; num1[0] = A.size(); int cnt = 0; for (int i = A.size() - 1; i >= 0; --i) { num1[ A.size() - i] = A[i]; } if (K == 0) { num2[0] = 1; num2[1] = 0; } while (K) { num2[++cnt] = (K % 10); K /= 10; } num2[0] = cnt; int n = max(num2[0],num1[0]); for (int i = 1; i 9) { ans.push_back((num2[i] + num1[i]) % 10); num2[i + 1] += 1; if (i == n) ans.push_back(1); }else { ans.push_back(num2[i] + num1[i]); } } reverse(ans.begin(),ans.end()); return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/1.数组/1.简单/1588. 所有奇数长度子数组的和.html":{"url":"分标签刷题/1.数组/1.简单/1588. 所有奇数长度子数组的和.html","title":"1588. 所有奇数长度子数组的和","keywords":"","body":"1588. 所有奇数长度子数组的和思路方法1：移动窗口1588. 所有奇数长度子数组的和 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1： 输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2： 输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3： 输入：arr = [10,11,12] 输出：66 提示： 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：移动窗口 我们首先遍历一个i（i为奇数），表示此次往数组中取i个数。 然后利用一个临时变量temp保存数组的前i个连续数的和。 将这个temp加入到ans答案中，然后依次往后移动，每次移动t时temp减去窗口的第一个数然后再加上后面进来的那个数。 每移动一次都要将temp加入到ans答案中。到移动到我们窗口的最后一个数为数组的最后一个数时，就不再移动。 进行下一次i的操作，当我们的i大于数组长度时，退出遍历，此时数组没有这么多个数给你去取了。 代码 class Solution { public: int sumOddLengthSubarrays(vector& arr) { int ans = 0; if (arr.empty()) { return ans; } for (int i = 1; ;i = i + 2) { if (i > arr.size()) break; int temp = 0; int j = 0; for ( ; j By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/1.数组/1.简单/977.有序数组的平方.html":{"url":"分标签刷题/1.数组/1.简单/977.有序数组的平方.html","title":"977.有序数组的平方","keywords":"","body":"977. 有序数组的平方思路a.双指针法977. 有序数组的平方 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 -10000 A 已按非递减顺序排序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 a.双指针法 我们首先找到数组中第一个大于等于0的值，将右指针指向它，左指针初始化为右指针的前面一个下标（最后一个负数） 然后我们依次比较左右指针所指向值的绝对值大小，将较小的插入到答案数组中，然后移动左指针或者右指针。 知道我们左指针或者右指针没有可移动时，退出循环。 然后再将左右指针中那个还没有移动完的一方依次插入到答案数组中。 最终返回这个答案数组即可 时间复杂度：O(n) 遍历两边数组即可，第一遍找第一个大于等于0的下标，第二遍移动双指针，依次插入到答案数组中。 代码 class Solution { public: vector sortedSquares(vector& A) { vector ans; if (!A.size()) { return A; } int l = -1, r = 0; for(auto i : A) { if (i = 0 && r = 0 && r = 0) { ans.push_back(A[l] * A[l]); l--; } while (r By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/1.数组/1.简单/面试题 17.10. 主要元素.html":{"url":"分标签刷题/1.数组/1.简单/面试题 17.10. 主要元素.html","title":"面试题 17.10. 主要元素","keywords":"","body":"面试题 17.10. 主要元素思路a.哈希表b.摩尔投票法面试题 17.10. 主要元素 数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。 示例 1： 输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2： 输入：[3,2] 输出：-1 示例 3： 输入：[2,2,1,1,1,2,2] 输出：2 说明： 你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-majority-element-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 a.哈希表 使用哈希表(unordered_map)来存取每个数的个数，然后遍历一遍，就能找到个数大于数组长度一半的数了。 时间复杂度：O(N) 空间复杂度：O(N) 代码 class Solution { public: int majorityElement(vector& nums) { unordered_map mmap; for (int i : nums) { mmap[i]++; if (mmap[i] > nums.size() / 2) { return i; } } return -1; } }; b.摩尔投票法 设置一个众数major,一个计数器cnt, 初始时major任意值，cnt=0, 从下标0开始枚举数组，如果cnt=0，major=nums[i], 如果cnt!=0,如果nums[i] == major，cnt++，否则cnt--; 继续循环，循环结束后如果cnt0,要进行一轮数组遍历，判断major是否为众数。 major不是众数就没有众数。 时间复杂度：O(N) 需遍历整个数组 空间复杂度：O(1) 只需要维护一个major和cnt 代码 class Solution { public: int majorityElement(vector& nums) { if (nums.size() == 0) { return -1; } int cnt = 0, most, temp = 0; for (auto i : nums) { if (cnt == 0) { most = i; } if (i == most) { cnt++; }else { cnt--; } } if (cnt nums.size() / 2) return most; } return -1; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/10.字典树/2.中等/648. 单词替换.html":{"url":"分标签刷题/10.字典树/2.中等/648. 单词替换.html","title":"648. 单词替换","keywords":"","body":"648. 单词替换思路方法1：字典树648. 单词替换 在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor) 如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根 则用最短的词根替换它。 你需要输出替换之后的句子。 示例 1： 输入：dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\" 输出：\"the cat was rat by the bat\" 示例 2： 输入：dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\" 输出：\"a a b c\" 示例 3： 输入：dictionary = [\"a\", \"aa\", \"aaa\", \"aaaa\"], sentence = \"a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa\" 输出：\"a a a a a a a a bbb baba a\" 示例 4： 输入：dictionary = [\"catt\",\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\" 输出：\"the cat was rat by the bat\" 示例 5： 输入：dictionary = [\"ac\",\"ab\"], sentence = \"it is abnormal that this solution is accepted\" 输出：\"it is ab that this solution is ac\" 提示： 1 1 dictionary[i] 仅由小写字母组成。 1 sentence 仅由小写字母和空格组成。 sentence 中单词的总量在范围 [1, 1000] 内。 sentence 中每个单词的长度在范围 [1, 1000] 内。 sentence 中单词之间由一个空格隔开。 sentence 没有前导或尾随空格。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/replace-words 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：字典树 本题是一个典型的字典树题，我们使用几个node结点来保存每个词根单词，对于末尾我们将这个结点的flag标记为1，表示以改点结尾的路径形成一个单词。 然后我们遍历字符串，去字典树中找最短前缀即可。 代码 class Solution { public: struct node{ char c; int flag; node *next[26]; node(char _c) { c = _c; flag = 0; for (int i = 0; i & dictionary, string sentence) { string ans=\"\"; node *root = new node('-'); for (auto &i : dictionary) { node *q = root; for (auto &j : i) { if (q->next[j - 97] == NULL) { q->next[j - 97] = new node(j); q = q->next[j - 97]; }else { q = q->next[j - 97]; } } q->flag = 1; } string temp = \"\"; sentence += \" \";//在末尾加一个空格，以便判断 for (auto &i : sentence) { if (i != ' ') { temp += i; }else { ans += \" \"; node *q = root; string temp1 = \"\"; for (auto &j : temp) { if (q->next[j - 97] == NULL) { q = q->next[j - 97]; ans += temp; break; }else { q = q->next[j - 97]; temp1 += q->c; if (q->flag == 1) { ans += temp1; break; } } } if (q && q->flag != 1) {//当某个单词它的每个字符在字典树上都能匹配到，但是它不能形成一个词根。 ans += temp; } temp = \"\"; } } return {ans.begin() + 1, ans.end()}; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/11.单调栈单调队列/42. 接雨水.html":{"url":"分标签刷题/11.单调栈单调队列/42. 接雨水.html","title":"42. 接雨水","keywords":"","body":"class Solution { public: int mmax[30005] = {0}; int hei[30005] = {0}; int trap(vector& height) { int ans = 0; int temp = 0; if (height.empty()) { return ans; } stack stk; for (int i = 0; i = height[stk.top()] ) { hei[i] += hei[stk.top()] + height[stk.top()]; ans -= mmax[stk.top()]; if (stk.size() == 1) { ans += height[stk.top()] * (i - stk.top()-1) - hei[i] + height[stk.top()]; hei[i] = 0; } stk.pop(); } mmax[i] = 0; if (!stk.empty()) { mmax[i] = (i - stk.top() - 1) * height[i] -hei[i]; ans += mmax[i]; } stk.push(i); } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/11.单调栈单调队列/85. 最大矩形.html":{"url":"分标签刷题/11.单调栈单调队列/85. 最大矩形.html","title":"85. 最大矩形","keywords":"","body":"85. 最大矩形思路方法1：单调栈85. 最大矩形 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] 输出：6 解释：最大矩形如上图所示。 示例 2： 输入：matrix = [] 输出：0 示例 3： 输入：matrix = [[\"0\"]] 输出：0 示例 4： 输入：matrix = [[\"1\"]] 输出：1 示例 5： 输入：matrix = [[\"0\",\"0\"]] 输出：0 提示： $rows == matrix.length$ $cols == matrix[0].length$ $0 $matrix[i][j] 为 '0' 或 '1'$ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximal-rectangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：单调栈 本题我们可以使用单调栈来做。 我们遍历二维数组，每一行我们做如下操作。 对于二维数组每一列我们往上计算一个高度（一列中连续的1的行数）。 然后利用两个单调栈维护每一列左边离该列最近小于它的高度的下标$l$，以及右边离该列最近的小于它的高度的下标$r$。那么我们就可以计算出以$i$列的高度为宽的矩形面积$S=h_i\\times(r-l-1)$。然后从这些面积中找到最大值即为我们的答案。 值得注意的是我们的下标应该从1开始，因为我们需要将高度数组h中的第0列以及第n+1列的高度设为-1，这是我们维护的h数组的界限。 时间复杂度：$O(nm)$，n为数组的行数，m为数组的列数。我们单调栈维护最近最大或最近最小的时间复杂度为$O(1)$,我们只需要遍历每一行每一列即可。 空间复杂度：$O(nm)$，对于每一行每一列要维护一个单调栈。 代码 class Solution { public: int h[205] = {0}; int maximalRectangle(vector>& matrix) { int ans = 0; if (matrix.size() == 0) { return ans; } h[0] = -1; h[matrix[0].size() + 1] = -1; for (int i = 0; i stk1, stk2; stk1.push(0); stk2.push(matrix[i].size() + 1); for (int j = 0; j = 1; ++j, --k) { while (stk1.size() && h[stk1.top()] >= h[j]) stk1.pop(); while (stk2.size() && h[stk2.top()] >= h[k]) stk2.pop(); l[j] = stk1.top(); r[k] = stk2.top(); stk1.push(j); stk2.push(k); } for (int j = 1; j By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/2.搜索大冲浪/2.中等/1091. 二进制矩阵中的最短路径.html":{"url":"分标签刷题/2.搜索大冲浪/2.中等/1091. 二进制矩阵中的最短路径.html","title":"1091. 二进制矩阵中的最短路径","keywords":"","body":"1091. 二进制矩阵中的最短路径思路方法1：BFS1091. 二进制矩阵中的最短路径 在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。 一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, ..., C_k 组成： 相邻单元格 Ci 和 C{i+1} 在八个方向之一上连通（此时，Ci 和 C{i+1} 不同且共享边或角） C_1 位于 (0, 0)（即，值为 grid[0][0]） C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]） 如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0） 返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。 示例 1： 输入：[[0,1],[1,0]] 输出：2 示例 2： 输入：[[0,0,0],[1,1,0],[1,1,0]] 输出：4 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shortest-path-in-binary-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：BFS 本题是一个最短路劲问题，所以我们需要使用广度优先搜索（BFS）来求解。 既然是搜索问题，我们就需要了解本题搜索的五大要素： 状态：每个点的坐标以及到改点所用的步数。 起始状态：从（0,0）点开始搜索，此时所用步数为1。 终止状态：坐标（N-1,N-1),此时结束搜索，返回答案。 状态转移：每个状态坐标可以往他的上，下，左，右，左下，右下，左上，右上八个方向移动（建立一个方向数组） 需要判断我们所走的方向是0还是1，是1的话则不能进行转移，是0并且没有走过的话就可以转移，将改点加入到队列，所用步数加1 去重：利用一个标记数组，当我们去过某点时，就将它标记上，避免重复搜索。 以上就是我们本题搜索的五大要素，值得注意的时，当我们遍历的第一个结点（起始结点）就是我们的终止状态时，应直接返回1，不用进行搜索。当我们搜索了所有结点都未能到达我们的终点时，返回一个-1，表示无法到达。当我们的起始结点或者终止结点为1时，也是不能到达的，此时返回-1. 接下来就是我们的代码实现了 代码 class Solution { public: struct node { int x, y, step; }; int mark[105][105] = {0}; int n, m; queue que; int dir[8][2] = {-1, 0, 1, 0, 0, 1, 0, -1, -1, -1, 1, 1, -1, 1, 1, -1}; int shortestPathBinaryMatrix(vector>& grid) { n = grid.size(), m = grid[0].size(); if (!n || grid[0][0] || grid[n - 1][m - 1] ) { return -1; } que.push((node){0, 0, 1}); mark[0][0] = 1; while (!que.empty()) { node temp = que.front(); if (temp.x == n - 1 && temp.y == n - 1 ) { return temp.step; } que.pop(); for (int i = 0 ; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/2.搜索大冲浪/2.中等/417. 太平洋大西洋水流问题.html":{"url":"分标签刷题/2.搜索大冲浪/2.中等/417. 太平洋大西洋水流问题.html","title":"417. 太平洋大西洋水流问题","keywords":"","body":"417. 太平洋大西洋水流问题思路方法1：BFS417. 太平洋大西洋水流问题 给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。 规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。 请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 提示： 输出坐标的顺序不重要 m 和 n 都小于150 示例： 给定下面的 5x5 矩阵: 太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * 大西洋 返回: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pacific-atlantic-water-flow 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：BFS 本题是一个关于地图的连通性问题，需要我们寻找既可以流到大西洋，又能流到太平洋的点，我们首先想到的肯定是遍历每个点，然后判断它能不能流到大西洋和太平洋，这也是我最初的想法，但是我们能不能有一种方法可以尽量的少遍历呢？ 答案当然是有的，我们可以从太平洋和大西洋开始遍历（逆流而上），然后将两个洋都能遍历到的点标记出来，放入我们的答案中，最终就能完成该题了。 同样我们使用广搜来做这一题，我们需要进行两次搜索，一次是从太平洋开始搜（最上方的点和最左方的点） 一次是从大西洋开始搜（最下方和最右方的点）。 同样我们需要列出我们广搜五大要素 状态：每个坐标点就是一个状态 初始状态：两次搜索分别从太平洋的点和大西洋的点开始搜索 终止状态：每次搜索搜到没有任何点可以再搜索为止。 状态转移：因为我们是逆流的，所以我们每次状态转移时，转移的状态（坐标）的高度，要大于等于当前状态（坐标）的高度。 并且我们不能进行重复搜索，在满足条件下，我们可以通过方向数组往上下左右四个方向转移。 去重：我们对每个点有如下标记，能到达太平洋的，标记为1，能到达大西洋的，标记为2，两个都能到达的标记为3。 最终得到所有标记为3的点，即为我们的答案。 接下来我们注意的小细节是 a.当矩阵为空时，我们应该返回一个空的答案 b.标记数组要初始化0 代码 class Solution { public: struct node { int x, y; }; int dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1}; int mark[200][200] = {0}; queue que; int n , m; vector> pacificAtlantic(vector>& matrix) { if (matrix.empty()) { return {}; } vector > ans; n = matrix.size(), m = matrix[0].size(); for (int i = 0; i 结果如下： By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/2.搜索大冲浪/2.中等/994.腐烂的橘子.html":{"url":"分标签刷题/2.搜索大冲浪/2.中等/994.腐烂的橘子.html","title":"994.腐烂的橘子","keywords":"","body":"994. 腐烂的橘子思路方法1：BFS994. 腐烂的橘子 在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4 示例 2： 输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。 示例 3： 输入：[[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1 1 grid[i][j] 仅为 0、1 或 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotting-oranges 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：BFS 因为本题是求最少分钟数，所以我们应该用广度优先搜索（BFS）要做这题。 还是利用我们做广搜的套路，我们需要列出我们广搜五元素。 状态：我们每个坐标点算一个状态，还有改点被腐烂时的分钟数 起始状态：起始的时候所有已经腐烂的点，以及它们的分钟数（0）。 终止状态：已经没有可以腐烂的橘子了，记录最后一个橘子被腐烂的分钟数。 状态转移：我们每次可以从队列中取出一个腐烂的橘子的坐标。（利用方向数组） 往符合条件的坐标移动（该坐标有橘子并且没有被腐烂过，改点的坐标必须在二维数组上合法）。 然后将该坐标加入我们的队列，将该点的值改为2，表示已经腐烂了。 去重：每次遍历到一个新鲜的橘子，就将它的值改为2，标记成腐烂的橘子，后续不再会搜索它，然后加入队列，以便后续搜索 我们需要一个node结构体，来保存我们的状态 我们需要一个方向数组，以便我们后续遍历我们的方向 我们需要一个答案变量ans，来记录我们最后一个橘子被腐烂的分钟数。 我们还需要记录我们开始的时候新鲜橘子的个数cnt，以便后续统计我们是否将我们的橘子完全腐烂掉。 如果没有完全腐烂掉就返回 -1，否则返回我们的答案ans。 废话不多说，贴代码。 代码 class Solution { public: struct node { int x, y, step; }; int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1}; int n, m; int ans = 0; int cnt = 0; queue que; int orangesRotting(vector>& grid) { n = grid.size(), m = grid[0].size(); if (!n || !m) { return -1; } for (int i = 0 ; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/3.树/1.简单/剑指 Offer 68 - I. 二叉搜索树的最近公共祖先.html":{"url":"分标签刷题/3.树/1.简单/剑指 Offer 68 - I. 二叉搜索树的最近公共祖先.html","title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先","keywords":"","body":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先思路方法1：递归剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 思路 方法1：递归 应该是二叉搜索树，我们可以根据当前结点值的大小的和p，q两个结点值的大小，判断p，q两个结点在当前结点同侧还是异侧，如果在同侧则递归到当前结点的左节点和右节点，这取决于当前结点的值比p，q两个结点的值小还是大。如果在异侧，那么当前结点就是p，q两个结点的最近公共祖先返回即可。 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (root -> val > p -> val && root -> val > q -> val) { return lowestCommonAncestor(root -> left, p, q); }else if (root -> val val && root->val val) { return lowestCommonAncestor(root->right, p, q); } return root; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/3.树/1.简单/剑指 Offer 68 - II. 二叉树的最近公共祖先.html":{"url":"分标签刷题/3.树/1.简单/剑指 Offer 68 - II. 二叉树的最近公共祖先.html","title":"剑指 Offer 68 - II. 二叉树的最近公共祖先","keywords":"","body":"剑指 Offer 68 - II. 二叉树的最近公共祖先思路方法1:递归+队列剑指 Offer 68 - II. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:递归+队列 本题我们使用递归去寻找p，以及q，找到后利用回溯将它们的路径保存到两个队列中（从终点开始往根结点存，终点在队首，这样就可保证找到的第一个为最近公共祖先），然后在队列中找第一个相同的结点，那么这个结点就是我们的最近公共祖先。 值得注意的是，当我们的队列长度不同时，队列长度小的不需出队，当队列长度一样时，两个队列的元素要一起出队。 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { queue que; queue que1; if (!root) return NULL; find_node(root, p,que); find_node(root, q,que1); while (que.front() != que1.front()) { if (que.size() > que1.size()) { que.pop(); }else if (que.size() &que) { if (root == NULL) return NULL; if (root != q) { if (find_node(root -> left, q, que)) { que.push(root); return root; } if (find_node(root -> right, q, que)) { que.push(root); return root; } return NULL; } que.push(root); return root; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/3.树/2.中等/剑指 Offer 33. 二叉搜索树的后序遍历序列.html":{"url":"分标签刷题/3.树/2.中等/剑指 Offer 33. 二叉搜索树的后序遍历序列.html","title":"剑指 Offer 33. 二叉搜索树的后序遍历序列","keywords":"","body":"剑指 Offer 33. 二叉搜索树的后序遍历序列思路方法1：递归剑指 Offer 33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 示例 1： 输入: [1,6,3,2,5] 输出: false 示例 2： 输入: [1,3,2,6,5] 输出: true 提示： 数组长度 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递归 对于该题我们可以利用递归来对这棵树，以及这棵树的左子树和右子树来进行判断它是不是一颗二叉搜索树，从而得到总体的一颗树是不是一颗二叉搜索树。 首先，我们需要明白对于二叉搜索树中的每个结点，它的左子树一定小于它的结点值，它的右子树一定大于它的结点值。 然后对于后续遍历，它先遍历左子树，然后再遍历右子树，最后再遍历我们的根结点。 所以对于题目给我们的一个数组（后续遍历），我们可以遍历一遍数组，找到所有比数组末尾元素小的值，放入左子树的数组集合中，反之放到右子树数组集合中。当我们遍历到某个元素的值小于末尾元素，但是它前面出现过比末尾元素大的值，这时它一定不满足二叉搜索树的性质，直接返回false,结束递归。 那我们递归到什么时候就可以结束掉我们的递归，并返回true呢？ 当我们递归到树的结点个数小于等于2时，这时这颗子树一定满足二叉搜索树的性质，返回true即可。 接下来就是代码演示 代码 class Solution { public: bool verifyPostorder(vector& postorder) { int n = postorder.size() - 1; if (n temp1; vector temp2; int flag = 0; for (auto &i: postorder) { if (i postorder[n] || flag) { flag = 1; if (i postorder[n]){ temp2.push_back(i); } } } return verifyPostorder(temp1) && verifyPostorder(temp2); return true; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/3.树/2.中等/剑指 Offer 34. 二叉树中和为某一值的路径.html":{"url":"分标签刷题/3.树/2.中等/剑指 Offer 34. 二叉树中和为某一值的路径.html","title":"剑指 Offer 34. 二叉树中和为某一值的路径","keywords":"","body":"剑指 Offer 34. 二叉树中和为某一值的路径思路方法1：递归+回溯剑指 Offer 34. 二叉树中和为某一值的路径 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例: 给定如下二叉树，以及目标和 sum = 22， 返回: [ [5,4,11,2], [5,8,4,5] ] 提示： 节点总数 思路 方法1：递归+回溯 先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。 路径记录： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。 递推参数： 当前节点 root ，当前目标值 sum。 终止条件： 若节点 root 为空，则直接返回。 递推工作： 路径更新： 将当前节点值 root->val 加入路径 path ； 目标值更新： sum= sum - root.val（即目标值 sum 减至 0 ）； 路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 ans 。 先序遍历： 递归左 / 右子节点。 路径恢复： 向上回溯前，需要将当前节点从路径 path 中删除，即执行 path.pop_back() 。 代码如下，递归回溯还得多练。 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector temp; vector > ans; vector> pathSum(TreeNode* root, int sum) { if (root == nullptr) { return {}; } path(root, sum); return ans; } void path(TreeNode* root, int sum ) { if (root == nullptr) { temp.push_back(1); return ; } if (root -> val == sum && root -> left == nullptr && root -> right == nullptr) { temp.push_back(root -> val); ans.push_back(temp); return ; } temp.push_back(root -> val); path(root->left,sum - root->val); temp.pop_back(); path(root->right,sum - root->val); temp.pop_back(); return; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/3.树/2.中等/剑指 Offer 36. 二叉搜索树与双向链表.html":{"url":"分标签刷题/3.树/2.中等/剑指 Offer 36. 二叉搜索树与双向链表.html","title":"剑指 Offer 36. 二叉搜索树与双向链表","keywords":"","body":"剑指 Offer 36. 二叉搜索树与双向链表思路方法1：递归分治方法2：后续遍历+队列剑指 Offer 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递归分治 我们先找到二叉搜索树的最小结点以及最大结点，作为我们链表的头结点和尾结点。 然后从根结点开始递归，对于每个结点，我们依次判断它的左节点是否为空，右节点是否为空。 左节点不为空的话，我们找到它左子树中最大的那个结点，然后将这个最大的结点的后继指向该结点，该结点的前驱指向这个最大的结点。 对于右节点不为空的情况，我们找右子树中最小的结点，然后将最小结点的前驱指向该结点，该结点的后继指向这个最小的结点。 然后再次递归左子树和右子树，值得注意的是，我们需要在递归左子树和右子树后，才能改变左子树和右子树的相关指向。 时间复杂度O(nlon),对于每个结点我们需要找它的前驱和后继，每次需要O(logn) 代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* treeToDoublyList(Node* root) { if (root == NULL) { return root; } Node *head = findleft(root); Node *tail = findright(root); tran(root); head -> left = tail; tail -> right = head; return head; } Node *findleft(Node *root) { return root -> left == NULL ? root : findleft(root -> left); } Node *findright(Node *root) { return root -> right == NULL ? root : findright(root -> right); } void tran(Node *root) { if (root == NULL) return; if (root -> left != NULL) { Node *node = root->left; Node *mmax = findright(node); root -> left = findright(node); tran(node); mmax -> right = root; } if (root -> right != NULL) { Node *node = root -> right; Node *mmin = findleft(node); root -> right = mmin; tran(node); mmin -> left = root; } return ; } }; 方法2：后续遍历+队列 题解里有这里就不详细说了。 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/4.链表/2.中等/剑指 Offer 35. 复杂链表的复制.html":{"url":"分标签刷题/4.链表/2.中等/剑指 Offer 35. 复杂链表的复制.html","title":"剑指 Offer 35. 复杂链表的复制","keywords":"","body":"剑指 Offer 35. 复杂链表的复制思路方法1：哈希+扫描剑指 Offer 35. 复杂链表的复制 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3： 输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4： 输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希+扫描 本题是一个关于链表复制的题，我们需要对原有的链表进行深拷贝，将链表拷贝到新的地址。 本题的难点在于，random指针究竟是什么？它指向的是链表中的第几个节点。 对于上述难点，我们可以使用一个哈希表来映射原链表的每个结点和目标链表的结点，一一对应。 我们首先将原有链表中除了random变量，全部拷贝到新的链表中，并利用哈希表在新旧两个结点之间建立映射关系。 然后我们使用两个指针，一个从原链表头部开始遍历，一个从新链表头部开始遍历。 当我们遍历到原链表中的random指针不为NULL时，我们就利用哈希表，映射出原链表中的random对应的是新链表中的哪个节点，然后将新链表中遍历到的那个指针指向该映射出来的结点即可。 时间复杂度：O(n) 空间复杂度：O(n)//遍历两边即可 解释的可能不是很清楚，看代码就清晰很多了。 代码 /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: int cnt = 0; Node* copyRandomList(Node* head) { if (head == nullptr) { return NULL; } unordered_map mmap; Node *node = head -> next; Node *head1 = new Node(head->val); Node *temp = head1; mmap[head] = head1; while (node != NULL) { Node *node1 = new Node (node -> val); mmap[node] = node1; temp -> next = node1; temp = temp -> next; node = node -> next; } temp -> next = NULL; temp = head1; while (head) { if (head -> random != NULL) { temp -> random = mmap[head->random]; } temp = temp -> next; head = head -> next; } return head1; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/4.链表/2.中等/剑指 Offer 36. 二叉搜索树与双向链表.html":{"url":"分标签刷题/4.链表/2.中等/剑指 Offer 36. 二叉搜索树与双向链表.html","title":"剑指 Offer 36. 二叉搜索树与双向链表","keywords":"","body":"剑指 Offer 36. 二叉搜索树与双向链表思路方法1：递归分治方法2：后续遍历+队列剑指 Offer 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递归分治 我们先找到二叉搜索树的最小结点以及最大结点，作为我们链表的头结点和尾结点。 然后从根结点开始递归，对于每个结点，我们依次判断它的左节点是否为空，右节点是否为空。 左节点不为空的话，我们找到它左子树中最大的那个结点，然后将这个最大的结点的后继指向该结点，该结点的前驱指向这个最大的结点。 对于右节点不为空的情况，我们找右子树中最小的结点，然后将最小结点的前驱指向该结点，该结点的后继指向这个最小的结点。 然后再次递归左子树和右子树，值得注意的是，我们需要在递归左子树和右子树后，才能改变左子树和右子树的相关指向。 时间复杂度O(nlon),对于每个结点我们需要找它的前驱和后继，每次需要O(logn) 代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* treeToDoublyList(Node* root) { if (root == NULL) { return root; } Node *head = findleft(root); Node *tail = findright(root); tran(root); head -> left = tail; tail -> right = head; return head; } Node *findleft(Node *root) { return root -> left == NULL ? root : findleft(root -> left); } Node *findright(Node *root) { return root -> right == NULL ? root : findright(root -> right); } void tran(Node *root) { if (root == NULL) return; if (root -> left != NULL) { Node *node = root->left; Node *mmax = findright(node); root -> left = findright(node); tran(node); mmax -> right = root; } if (root -> right != NULL) { Node *node = root -> right; Node *mmin = findleft(node); root -> right = mmin; tran(node); mmin -> left = root; } return ; } }; 方法2：后续遍历+队列 题解里有这里就不详细说了。 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/5.分治算法/2.中等/剑指 Offer 36. 二叉搜索树与双向链表.html":{"url":"分标签刷题/5.分治算法/2.中等/剑指 Offer 36. 二叉搜索树与双向链表.html","title":"剑指 Offer 36. 二叉搜索树与双向链表","keywords":"","body":"剑指 Offer 36. 二叉搜索树与双向链表思路方法1：递归分治方法2：后续遍历+队列剑指 Offer 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递归分治 我们先找到二叉搜索树的最小结点以及最大结点，作为我们链表的头结点和尾结点。 然后从根结点开始递归，对于每个结点，我们依次判断它的左节点是否为空，右节点是否为空。 左节点不为空的话，我们找到它左子树中最大的那个结点，然后将这个最大的结点的后继指向该结点，该结点的前驱指向这个最大的结点。 对于右节点不为空的情况，我们找右子树中最小的结点，然后将最小结点的前驱指向该结点，该结点的后继指向这个最小的结点。 然后再次递归左子树和右子树，值得注意的是，我们需要在递归左子树和右子树后，才能改变左子树和右子树的相关指向。 时间复杂度O(nlon),对于每个结点我们需要找它的前驱和后继，每次需要O(logn) 代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* treeToDoublyList(Node* root) { if (root == NULL) { return root; } Node *head = findleft(root); Node *tail = findright(root); tran(root); head -> left = tail; tail -> right = head; return head; } Node *findleft(Node *root) { return root -> left == NULL ? root : findleft(root -> left); } Node *findright(Node *root) { return root -> right == NULL ? root : findright(root -> right); } void tran(Node *root) { if (root == NULL) return; if (root -> left != NULL) { Node *node = root->left; Node *mmax = findright(node); root -> left = findright(node); tran(node); mmax -> right = root; } if (root -> right != NULL) { Node *node = root -> right; Node *mmin = findleft(node); root -> right = mmin; tran(node); mmin -> left = root; } return ; } }; 方法2：后续遍历+队列 题解里有这里就不详细说了。 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/6.字符串/1.简单/剑指 Offer 58 - II. 左旋转字符串.html":{"url":"分标签刷题/6.字符串/1.简单/剑指 Offer 58 - II. 左旋转字符串.html","title":"剑指 Offer 58 - II. 左旋转字符串","keywords":"","body":"剑指 Offer 58 - II. 左旋转字符串思路方法1：双指针+扫描方法2：拼接+截取（学废了）剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1： 输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2： 输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" 限制： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：双指针+扫描 我们利用一个左指针和一个右指针来对字符串进行扫描，当n大于0时，将左指针的字符加到目标字符串，左指针加一，n减一，当n等于0时，我们将右指针的字符加到目标字符串（注意的是前面是加到目标字符串后面，这里是加到目标字符串前面），右指针减一。当左指针大于右指针时，退出循环，返回目标字符串即可。 时间复杂度：O(k),k为字符串长度 空间复杂度：O(1),不需要额外的空间 代码 class Solution { public: string reverseLeftWords(string s, int n) { string ans = \"\"; if (n == 0) { return s; } int l = 0, r = s.size() - 1; while (l 方法2：拼接+截取（学废了） 我们在原字符串后再加一个一样的字符串，然后从这个有两倍长度的字符串的第n个位置开始截取原字符串长度，返回即可。 一行代码即可完成 代码 class Solution { public: string reverseLeftWords(string s, int n) { return (s + s).substr(n, s.size()); } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/7.队列/1.简单/剑指 Offer 59 - I. 滑动窗口的最大值.html":{"url":"分标签刷题/7.队列/1.简单/剑指 Offer 59 - I. 滑动窗口的最大值.html","title":"剑指 Offer 59 - I. 滑动窗口的最大值","keywords":"","body":"剑指 Offer 59 - I. 滑动窗口的最大值思路方法1：暴力方法2：双端队列+单调队列剑指 Offer 59 - I. 滑动窗口的最大值 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：暴力 对于暴力，我们每次都遍历一遍窗口中的值，找到最大的即可。 时间复杂度：O(nk)，每次遍历k个元素找最大值，遍历n-k+1次。 空间复杂度：O(1)，不需要额外的空间 代码 class Solution { public: vector maxSlidingWindow(vector& nums, int k) { vector ans; if (nums.empty()) { return ans; } for (int i = 0; i 方法2：双端队列+单调队列 借鉴了题解大佬的题解，详细链接看下面 窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque ： deque内 仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i - 1] ，需将 deque内的对应元素一起删除。 deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j + 1] ，需将 deque 内所有 初始化： 双端队列 deque ，结果列表 ans ，数组长度 n ； 2.滑动窗口： 左边界范围 i∈[1−k,n+1−k] ，右边界范围 j∈[0,n−1] ； a.若 i > 0且 队首元素 deque[0] == 被删除元素 nums[i - 1],则队首元素出队； b.删除 deque内所有 返回值： 返回结果列表 ans 。 作者：jyd 链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 class Solution { public: vector maxSlidingWindow(vector& nums, int k) { vector ans; if (nums.empty()) { return ans; } deque deq; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/7.队列/2.中等/剑指 Offer 59 - II. 队列的最大值.html":{"url":"分标签刷题/7.队列/2.中等/剑指 Offer 59 - II. 队列的最大值.html","title":"剑指 Offer 59 - II. 队列的最大值","keywords":"","body":"剑指 Offer 59 - II. 队列的最大值思路方法1:维护单调递减的双端队列剑指 Offer 59 - II. 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 输入: [\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"] [[[[[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2： 输入: [\"MaxQueue\",\"pop_front\",\"max_value\"] [[[],[],[]] 输出: [null,-1,-1] 限制： 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:维护单调递减的双端队列 我们使用两个队列来完成这题，对于第一个队列和正常队列一样插入数据，弹出数据 本题我们的难点是，如何维护每次队列中的最大值，想了很久，我决定使用一个双端队列，用其维护队列中的最大值。 方法如下 当队列为空时，直接将该值压入两个队列。 当队列不为空时，我们就需要循环判断该值和双端队列队尾元素值的大小关系，如果双端队列的队尾元素小于插入进来的值的话，我们就应该一直出队，因为这个新插入来的值，一定比前面插入来的值后$pop$,所以它可以将所有小于它的值都去除掉。然后将其插入双端队列即可 我们的双端队列是单调递减的，所以双端队列的头部维护着我们队列中的最大值 当我们pop时，需要判断第一个队列中被pop掉的值（头部）是否和我们双端队列中头部的值相等，如果相等的话，需要将双端队列中头部的值也pop掉。以维护队列中的最大值。 上述就是我们本题的难点，其他就不细说了。 时间复杂度：$O(1)$（插入，删除，求最大值） 删除操作与求最大值操作显然只需要 O(1)的时间。 而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n个数字的插入过程，对应的所有出队操作也不会大于 n次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 $O(1)$。 空间复杂度：$O(n)$，需要用队列存储所有插入的元素。 代码 class MaxQueue { public: queue que; deque deq; MaxQueue() { } int max_value() { if (que.empty()) return -1; return deq.front(); } void push_back(int value) { if (que.empty()) { que.push(value); deq.push_back(value); }else { while (deq.size() && value > deq.back()) { deq.pop_back(); } deq.push_back(value); que.push(value); } } int pop_front() { if (que.empty()) return -1; int temp = que.front(); if (que.front() == deq.front()) { deq.pop_front(); } que.pop(); return temp; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj->max_value(); * obj->push_back(value); * int param_3 = obj->pop_front(); */ By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/8.动态规划/股票问题/股票问题大赏.html":{"url":"分标签刷题/8.动态规划/股票问题/股票问题大赏.html","title":"股票问题大赏","keywords":"","body":"2020-12-28188. 买卖股票的最佳时机 IV思路2020-12-28 188. 买卖股票的最佳时机 IV 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 0 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划 与本题类似的一共有六题，链接分别如下 121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费 解题思路如下网站！！！ 股票买卖问题解题大全 前面两道还不用涉及到动态规划，后面几道思路类似。 代码 121. 买卖股票的最佳时机 class Solution { public: int maxProfit(vector& prices) { if (!prices.size()) return 0; int ans = 0; int min = prices[0]; for (int i = 1 ; i 122. 买卖股票的最佳时机 II class Solution { public: int maxProfit(vector& prices) { if (!prices.size()) return 0; int ans = 0; for (int i = 1; i prices[i - 1]){ ans += prices[i] - prices[i - 1]; } } return ans; } }; 123. 买卖股票的最佳时机 III class Solution { public: int maxProfit(vector& prices) { if (prices.size() > > dp(prices.size() + 1, vector>(3, vector(2))); for (int i = 1; i 188. 买卖股票的最佳时机 IV class Solution { public: int maxProfit(int k, vector& prices) { if (prices.empty()) { return 0; } vector > > dp(prices.size() + 1,vector >(k + 1, vector(2))); for (int i = 1; i 309. 最佳买卖股票时机含冷冻期 class Solution { public: int maxProfit(vector& prices) { if (prices.size() > dp(prices.size() + 1, vector(2)); dp[0][1] = -prices[0]; for (int i = 1;i 714. 买卖股票的最佳时机含手续费 class Solution { public: int maxProfit(vector& prices, int fee) { int n = prices.size(); vector> dp(n, vector(2)); dp[0][0] = 0, dp[0][1] = -prices[0]; for (int i = 1; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"分标签刷题/9.贪心算法/2.中等/1353. 最多可以参加的会议数目.html":{"url":"分标签刷题/9.贪心算法/2.中等/1353. 最多可以参加的会议数目.html","title":"1353. 最多可以参加的会议数目","keywords":"","body":"1353. 最多可以参加的会议数目思路方法1：贪心算法+优先队列1353. 最多可以参加的会议数目 给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。 你可以在满足 startDayi 请你返回你可以参加的 最大 会议数目。 示例 1： 输入：events = [[1,2],[2,3],[3,4]] 输出：3 解释：你可以参加所有的三个会议。 安排会议的一种方案如上图。 第 1 天参加第一个会议。 第 2 天参加第二个会议。 第 3 天参加第三个会议。 示例 2： 输入：events= [[1,2],[2,3],[3,4],[1,2]] 输出：4 示例 3： 输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]] 输出：4 示例 4： 输入：events = [[1,100000]] 输出：1 示例 5： 输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]] 输出：7 提示： 1 events[i].length == 2 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：贪心算法+优先队列 这是一道典型的扫描算法题。由于每个时间点最多参加一个会议，我们可以从1开始遍历所有时间。 对于每一个时间点，所有在当前时间及之前时间开始，并且在当前时间还未结束的会议都是可参加的。显然，在所有可参加的会议中，选择结束时间最早的会议是最优的，因为其他会议还有更多的机会可以去参加。 怎样动态获得当前结束时间最早的会议呢？我们可以使用一个小根堆记录所有当前可参加会议的结束时间。在每一个时间点，我们首先将当前时间点开始的会议加入小根堆，再把当前已经结束的会议移除出小根堆（因为已经无法参加了），然后从剩下的会议中选择一个结束时间最早的去参加。 为了快速获得当前时间点开始的会议，我们以O(N)时间预处理得到每个时间点开始的会议的序号。 算法总的时间复杂度 $O(TlogN)$（这里的T为时间范围）。 代码 class Solution { public: #define MAX_N 1e5 + 1 int maxEvents(vector>& events) { int ans = 0, start = 1; vector > vec(MAX_N); int end = 0; for (auto &i : events) { vec[i[0]].push_back(i[1]); end = max(end, i[1]); } priority_queue, greater<> > que; while (start By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 35. 复杂链表的复制.html":{"url":"剑指Offer/剑指 Offer 35. 复杂链表的复制.html","title":"剑指 Offer 35. 复杂链表的复制","keywords":"","body":"剑指 Offer 35. 复杂链表的复制思路方法1：哈希+扫描剑指 Offer 35. 复杂链表的复制 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3： 输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4： 输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：哈希+扫描 本题是一个关于链表复制的题，我们需要对原有的链表进行深拷贝，将链表拷贝到新的地址。 本题的难点在于，random指针究竟是什么？它指向的是链表中的第几个节点。 对于上述难点，我们可以使用一个哈希表来映射原链表的每个结点和目标链表的结点，一一对应。 我们首先将原有链表中除了random变量，全部拷贝到新的链表中，并利用哈希表在新旧两个结点之间建立映射关系。 然后我们使用两个指针，一个从原链表头部开始遍历，一个从新链表头部开始遍历。 当我们遍历到原链表中的random指针不为NULL时，我们就利用哈希表，映射出原链表中的random对应的是新链表中的哪个节点，然后将新链表中遍历到的那个指针指向该映射出来的结点即可。 时间复杂度：O(n) 空间复杂度：O(n)//遍历两边即可 解释的可能不是很清楚，看代码就清晰很多了。 代码 /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: int cnt = 0; Node* copyRandomList(Node* head) { if (head == nullptr) { return NULL; } unordered_map mmap; Node *node = head -> next; Node *head1 = new Node(head->val); Node *temp = head1; mmap[head] = head1; while (node != NULL) { Node *node1 = new Node (node -> val); mmap[node] = node1; temp -> next = node1; temp = temp -> next; node = node -> next; } temp -> next = NULL; temp = head1; while (head) { if (head -> random != NULL) { temp -> random = mmap[head->random]; } temp = temp -> next; head = head -> next; } return head1; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 36. 二叉搜索树与双向链表.html":{"url":"剑指Offer/剑指 Offer 36. 二叉搜索树与双向链表.html","title":"剑指 Offer 36. 二叉搜索树与双向链表","keywords":"","body":"剑指 Offer 36. 二叉搜索树与双向链表思路方法1：递归分治方法2：后续遍历+队列剑指 Offer 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：递归分治 我们先找到二叉搜索树的最小结点以及最大结点，作为我们链表的头结点和尾结点。 然后从根结点开始递归，对于每个结点，我们依次判断它的左节点是否为空，右节点是否为空。 左节点不为空的话，我们找到它左子树中最大的那个结点，然后将这个最大的结点的后继指向该结点，该结点的前驱指向这个最大的结点。 对于右节点不为空的情况，我们找右子树中最小的结点，然后将最小结点的前驱指向该结点，该结点的后继指向这个最小的结点。 然后再次递归左子树和右子树，值得注意的是，我们需要在递归左子树和右子树后，才能改变左子树和右子树的相关指向。 时间复杂度O(nlon),对于每个结点我们需要找它的前驱和后继，每次需要O(logn) 代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node* treeToDoublyList(Node* root) { if (root == NULL) { return root; } Node *head = findleft(root); Node *tail = findright(root); tran(root); head -> left = tail; tail -> right = head; return head; } Node *findleft(Node *root) { return root -> left == NULL ? root : findleft(root -> left); } Node *findright(Node *root) { return root -> right == NULL ? root : findright(root -> right); } void tran(Node *root) { if (root == NULL) return; if (root -> left != NULL) { Node *node = root->left; Node *mmax = findright(node); root -> left = findright(node); tran(node); mmax -> right = root; } if (root -> right != NULL) { Node *node = root -> right; Node *mmin = findleft(node); root -> right = mmin; tran(node); mmin -> left = root; } return ; } }; 方法2：后续遍历+队列 题解里有这里就不详细说了。 By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 39. 数组中出现次数超过一半的数字.html":{"url":"剑指Offer/剑指 Offer 39. 数组中出现次数超过一半的数字.html","title":"剑指 Offer 39. 数组中出现次数超过一半的数字","keywords":"","body":"剑指 Offer 39. 数组中出现次数超过一半的数字思路方法1：哈希表（常规方法）方法2：排序（值得学习）方法3：摩尔计数（最优方法）剑指 Offer 39. 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 本题写出来的话较为简单，但是其中的方法值得学习 思路 方法1：哈希表（常规方法） 我们利用哈希表记录每个数在数组中出现的次数，当有某个数的次数大于数组长度的一半时，返回该数即可 时间复杂度：$O(n)$，遍历一遍数组 空间复杂度：$O(n)$，需要保存数组中每个数字，记录个数 代码 class Solution { public: int majorityElement(vector& nums) { unordered_map mmap; for (auto &i : nums) { mmap[i]++; if (mmap[i] > nums.size() / 2) return i; } return 0; } }; 方法2：排序（值得学习） 我们将数组排序，然后中间那个值肯定就是我们的答案。 时间复杂度：$O(nlogn)$，排序所需的时间复杂度 空间复杂度：$O(logn)$，归并排序以及快排都需要递归，这也是需要消耗内存空间的。 代码 class Solution { public: int majorityElement(vector& nums) { sort(nums.begin(), nums.end()); return nums[nums.size() / 2]; } }; 方法3：摩尔计数（最优方法） 摩尔投票法： 设输入数组 nums 的众数为 x ，数组长度为 n 。 推论一： 若记众数的票数为+1 ，非众数的票数为−1 ，则一定有所有数字的票数和>0 。 推论二： 若数组的前 a个数字的票数和=0 ，则数组剩余(n−a)个数字的 票数和一定仍>0 ，即后(n−a) 个数字的众仍为 x 。 根据以上推论，假设数组首个元素 $n_1$为众数，遍历并统计票数。当发生票数和=0 时，剩余数组的众数一定不变 ，这是由于： 当 $n_1=x$ ： 抵消的所有数字，有一半是众数 x 。 当$ n_1 \\neq x$： 抵消的所有数字，少于或等于一半是众数 x 。 利用此特性，每轮假设发生票数和=0 都可以缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数。 算法流程: 初始化： 票数统计votes = 0 ， 众数 x； 循环： 遍历数组nums 中的每个数字 num ； 当 票数 votes 等于 0 ，则假设当前数字 num 是众数； 当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 ； 返回值： 返回 x 即可； 时间复杂度：$O(n)$，遍历一遍数组 空间复杂度：$O(1)$，不需要额外的空间 代码 class Solution { public: int majorityElement(vector& nums) { int votes = 0, num; for (auto &i : nums) { if (votes == 0) { num = i; votes++; }else { if (i == num) { votes++; }else { votes--; } } } return num; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 58 - II. 左旋转字符串.html":{"url":"剑指Offer/剑指 Offer 58 - II. 左旋转字符串.html","title":"剑指 Offer 58 - II. 左旋转字符串","keywords":"","body":"剑指 Offer 58 - II. 左旋转字符串思路方法1：双指针+扫描方法2：拼接+截取（学废了）剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1： 输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2： 输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" 限制： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：双指针+扫描 我们利用一个左指针和一个右指针来对字符串进行扫描，当n大于0时，将左指针的字符加到目标字符串，左指针加一，n减一，当n等于0时，我们将右指针的字符加到目标字符串（注意的是前面是加到目标字符串后面，这里是加到目标字符串前面），右指针减一。当左指针大于右指针时，退出循环，返回目标字符串即可。 时间复杂度：O(k),k为字符串长度 空间复杂度：O(1),不需要额外的空间 代码 class Solution { public: string reverseLeftWords(string s, int n) { string ans = \"\"; if (n == 0) { return s; } int l = 0, r = s.size() - 1; while (l 方法2：拼接+截取（学废了） 我们在原字符串后再加一个一样的字符串，然后从这个有两倍长度的字符串的第n个位置开始截取原字符串长度，返回即可。 一行代码即可完成 代码 class Solution { public: string reverseLeftWords(string s, int n) { return (s + s).substr(n, s.size()); } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 59 - I. 滑动窗口的最大值.html":{"url":"剑指Offer/剑指 Offer 59 - I. 滑动窗口的最大值.html","title":"剑指 Offer 59 - I. 滑动窗口的最大值","keywords":"","body":"剑指 Offer 59 - I. 滑动窗口的最大值思路方法1：暴力方法2：双端队列+单调队列剑指 Offer 59 - I. 滑动窗口的最大值 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：暴力 对于暴力，我们每次都遍历一遍窗口中的值，找到最大的即可。 时间复杂度：O(nk)，每次遍历k个元素找最大值，遍历n-k+1次。 空间复杂度：O(1)，不需要额外的空间 代码 class Solution { public: vector maxSlidingWindow(vector& nums, int k) { vector ans; if (nums.empty()) { return ans; } for (int i = 0; i 方法2：双端队列+单调队列 借鉴了题解大佬的题解，详细链接看下面 窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque ： deque内 仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i - 1] ，需将 deque内的对应元素一起删除。 deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j + 1] ，需将 deque 内所有 算法流程： 1.初始化： 双端队列 deque ，结果列表 ans ，数组长度 n ； 2.滑动窗口： 左边界范围 i∈[1−k,n+1−k] ，右边界范围 j∈[0,n−1] ； ​ a.若 i > 0且 队首元素 deque[0] == 被删除元素 nums[i - 1],则队首元素出队； ​ b.删除 deque内所有 ​ c.将nums[j] 添加至 deque尾部； ​ d.若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 ans 。 3.返回值： 返回结果列表 ans 。 作者：jyd 链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 class Solution { public: vector maxSlidingWindow(vector& nums, int k) { vector ans; if (nums.empty()) { return ans; } deque deq; for (int i = 0; i By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 59 - II. 队列的最大值.html":{"url":"剑指Offer/剑指 Offer 59 - II. 队列的最大值.html","title":"剑指 Offer 59 - II. 队列的最大值","keywords":"","body":"剑指 Offer 59 - II. 队列的最大值思路方法1:维护单调递减的双端队列剑指 Offer 59 - II. 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 输入: [\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"] [[[[[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2： 输入: [\"MaxQueue\",\"pop_front\",\"max_value\"] [[[],[],[]] 输出: [null,-1,-1] 限制： 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1:维护单调递减的双端队列 我们使用两个队列来完成这题，对于第一个队列和正常队列一样插入数据，弹出数据 本题我们的难点是，如何维护每次队列中的最大值，想了很久，我决定使用一个双端队列，用其维护队列中的最大值。 方法如下 当队列为空时，直接将该值压入两个队列。 当队列不为空时，我们就需要循环判断该值和双端队列队尾元素值的大小关系，如果双端队列的队尾元素小于插入进来的值的话，我们就应该一直出队，因为这个新插入来的值，一定比前面插入来的值后$pop$,所以它可以将所有小于它的值都去除掉。然后将其插入双端队列即可 我们的双端队列是单调递减的，所以双端队列的头部维护着我们队列中的最大值 当我们pop时，需要判断第一个队列中被pop掉的值（头部）是否和我们双端队列中头部的值相等，如果相等的话，需要将双端队列中头部的值也pop掉。以维护队列中的最大值。 上述就是我们本题的难点，其他就不细说了。 时间复杂度：$O(1)$（插入，删除，求最大值） 删除操作与求最大值操作显然只需要 O(1)的时间。 而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n个数字的插入过程，对应的所有出队操作也不会大于 n次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 $O(1)$。 空间复杂度：$O(n)$，需要用队列存储所有插入的元素。 代码 class MaxQueue { public: queue que; deque deq; MaxQueue() { } int max_value() { if (que.empty()) return -1; return deq.front(); } void push_back(int value) { if (que.empty()) { que.push(value); deq.push_back(value); }else { while (deq.size() && value > deq.back()) { deq.pop_back(); } deq.push_back(value); que.push(value); } } int pop_front() { if (que.empty()) return -1; int temp = que.front(); if (que.front() == deq.front()) { deq.pop_front(); } que.pop(); return temp; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj->max_value(); * obj->push_back(value); * int param_3 = obj->pop_front(); */ By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 63. 股票的最大利润.html":{"url":"剑指Offer/剑指 Offer 63. 股票的最大利润.html","title":"剑指 Offer 63. 股票的最大利润","keywords":"","body":"剑指 Offer 63. 股票的最大利润思路方法1：记录+循环剑指 Offer 63. 股票的最大利润 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：记录+循环 对于每一天我们交易掉该股票能赚取的前等于该天的价格减去改天以前包含改天中价格最低的那天的价钱（表明我们是那天买的），每次计算完都维护一个整体最大值$ans$,遍历完数组返回答案即可。 时间复杂度：$O(n)$，遍历一遍数组即可 空间复杂度：$O(1)$，只需一个额外的变量保存局部最小值，然后就不再需要额外的空间来保存中间值 代码 class Solution { public: int maxProfit(vector& prices) { int ans = 0, mmin = INT32_MAX; if (prices.empty()) { return ans; } for (auto &i : prices) { mmin = min(i, mmin); ans = max(ans, i - mmin); } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 64. 求1+2+…+n.html":{"url":"剑指Offer/剑指 Offer 64. 求1+2+…+n.html","title":"剑指 Offer 64. 求1+2+…+n","keywords":"","body":"剑指 Offer 64. 求1+2+…+n1思路方法1：短路原则+递归剑指 Offer 64. 求1+2+…+n1 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 限制： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qiu-12n-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：短路原则+递归 因为递归都是需要条件判断来确定条件边界的，但是这里不能用if，所以我们可以使用一个短路原则。 设置一个遍历b，当n>0时，b为真，否则b为假。 使用如下表达式 $b\\&\\&(sum = sumNums(n - 1) + n)$ 含义就是如果b为假，后面的表达式将不会执行，否则执行后面的表达式（递归） 代码 class Solution { public: int sumNums(int n) { int sum = 0; int b = n > 0; b && (sum = sumNums(n - 1) + n); return sum; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "},"剑指Offer/剑指 Offer 66. 构建乘积数组.html":{"url":"剑指Offer/剑指 Offer 66. 构建乘积数组.html","title":"剑指 Offer 66. 构建乘积数组","keywords":"","body":"剑指 Offer 66. 构建乘积数组思路方法1：动态规划+循环剑指 Offer 66. 构建乘积数组 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例: 输入: [1,2,3,4,5] 输出: [120,60,40,30,24] 提示： 所有元素乘积之和不会溢出 32 位整数 a.length 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 方法1：动态规划+循环 大佬的解法如下： 本题的难点在于 不能使用除法 ，即需要只用乘法 生成数组 B。根据题目对 B[i]的定义，可列表格，如下图所示。 根据表格的主对角线（全为 1 ），可将表格分为 上三角 和 下三角 两部分。分别迭代计算下三角和上三角两部分的乘积，即可不使用除法 就获得结果。 算法流程： 初始化：数组 B ，其中B[0]=1 ；辅助变量tmp=1 ； 计算 B[i]的 下三角各元素的乘积，直接乘入B[i] ； 计算 B[i]的 上三角 各元素的乘积，记为 tmp，并乘入B[i] ； 返回 B 。 复杂度分析： 时间复杂度 $O(N)$ ： 其中 N 为数组长度，两轮遍历数组 a，使用O(N) 时间。 空间复杂度 $O(1)$ ： 变量 tmp 使用常数大小额外空间（数组 b作为返回值，不计入复杂度考虑）。 作者：jyd 链接：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 class Solution { public: vector constructArr(vector& a) { if (a.empty()) { return {}; } vector ans; ans.push_back(1); for (int i = 0; i = 0; --i) { ans[i] *= temp; temp *= a[i]; } return ans; } }; By longkejie，使用知识共享 署名-相同方式共享 4.0协议发布            updated 2021-03-12 04:41:50 "}}