# 2020-12-12

## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)



如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:

输入: [1,7,4,9,2,5]

输出: 6 

解释: 整个序列均为摆动序列。

示例 2:

输入: [1,17,5,10,13,15,10,5,16,8]

输出: 7

解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

示例 3:

输入: [1,2,3,4,5,6,7,8,9]

输出: 2

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/wiggle-subsequence

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路

#### 方法1：动态规划（二维数组）

首先是自己的思路，比较笨，但是感觉好理解

利用一个二维数组，dp\[i][3],第一维为以数组小标为i结尾的序列的长度，第二维总共有0,1,2三种情况，代表的是以数组中第i个数结束，它是以什么情况结束的。是以不是升序也不是降序，还是以升序，又或者以降序结束。

然后我利用两层循环，第一层循环分别统计倒数第二个数是以0 -  n-1的情况，再第二层循环计算，最后一个数为第一层循环的后面的数。

每次计算都记录一个最大值。

**时间复杂度**：O(n^2)

**空间复杂度**“：O(n)

太菜了，可能解释的不是很清楚，直接看代码理解吧。

##### 代码

```cpp
class Solution {
public:
    int dp[1000000][3] = {0};
    int wiggleMaxLength(vector<int>& nums) {
        int ans = 1;
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() < 2) {
            return 1;
        }
        for (int i = 0; i < nums.size(); ++i) {
            dp[i][0] = 1;
            dp[i][1] = 1;
            dp[i][2] = 1;
        }
        for (int i = 0; i < nums.size() - 1; ++i) {
            for (int j = i + 1; j < nums.size(); ++j) {
                if (nums[j] > nums[i]) {
                    dp[j][2] = max(dp[i][1] + 1, dp[j][2]);
                    ans = max(ans, dp[j][2]);
                }else if (nums[j] < nums[i]){
                    dp[j][1] = max(dp[i][2] + 1, dp[j][1]);
                    ans = max(ans, dp[j][1]);
                }
            }
        }
        return ans;
    }
};
```



#### 方法二：贪心算法（官方解答）

观察这个序列可以发现，我们不断地交错选择「峰」与「谷」，可以使得该序列尽可能长。证明非常简单：如果我们选择了一个「过渡元素」，那么在原序列中，这个「过渡元素」的两侧有一个「峰」和一个「谷」。不失一般性，我们假设在原序列中的出现顺序为「峰」「过渡元素」「谷」。如果「过渡元素」在选择的序列中小于其两侧的元素，那么「谷」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「谷」；同理，如果「过渡元素」在选择的序列中大于其两侧的元素，那么「峰」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「峰」。这样一来，我们总可以将任意满足要求的序列中的所有「过渡元素」替换成「峰」或「谷」。并且由于我们不断地交错选择「峰」与「谷」的方法就可以满足要求，因此这种选择方法就一定可以达到可选元素数量的最大值。

这样，我们只需要统计该序列中「峰」与「谷」的数量即可（注意序列两端的数也是「峰」或「谷」），但需要注意处理相邻的相同元素。

在实际代码中，我们记录当前序列的上升下降趋势。每次加入一个新元素时，用新的上升下降趋势与之前对比，如果出现了「峰」或「谷」，答案加一，并更新当前序列的上升下降趋势。

##### 代码

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) {
            return n;
        }
        int prevdiff = nums[1] - nums[0];
        int ret = prevdiff != 0 ? 2 : 1;
        for (int i = 2; i < n; i++) {
            int diff = nums[i] - nums[i - 1];
            cout << diff << " " << prevdiff << endl;
            if ((diff > 0 && prevdiff <= 0) || (diff < 0 && prevdiff >= 0)) {
                ret++;
                prevdiff = diff;
            }
        }
        return ret;
    }
};
```

