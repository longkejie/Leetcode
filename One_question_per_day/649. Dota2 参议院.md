# 2020-12-11

## [649. Dota2 参议院](https://leetcode-cn.com/problems/dota2-senate/)

Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：

禁止一名参议员的权利：

参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。

宣布胜利：

如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。

给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输
出应该是 Radiant 或 Dire。

示例 1：

输入："RD"

输出："Radiant"

解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任

权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人

示例 2：

输入："RDD"

输出："Dire"

解释：

第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利

第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止

第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利

因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/dota2-senate

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



### 思路

#### 方法1：贪心模拟+栈



本题我们可以用栈来进行模拟，先记录每个阵营成员的个数，然后遍历字符串，对于入栈出栈操作如下。

我们利用一个循环，当每个阵营成员个数都大于0时，满足循环条件，进入循环。

在循环中，我们遍历我们的字符串。

下面就是我们的入栈出栈操作

1.当栈为空时，如果遍历到的字符为'D'或者'R',直接将该字符入栈。

2.栈不为空时，我们需要考虑两种情况

​		a.栈顶元素与遍历到的元素相同，直接入栈即可。

​		b.栈顶元素与遍历到的元素不同，将字符串中遍历到的相应的元素改为'0',表示下次不再遍历该元素（出局了），将遍历到的元素所属			阵营的成员个数减一，将栈顶元素出栈。

在循环中当我们判断到某个阵营成员个数为0的时候，退出循环。

然后根据阵营剩余成员个数的大小来判断哪个阵营获胜。



代码如下：

##### 代码

```cpp
class Solution {
public:
    string predictPartyVictory(string senate) {
        unordered_map<char, int> mmap;
        for (int i = senate.size() - 1; i >= 0; --i) {
            mmap[senate[i]]++;
        }
        stack<char> stk;
        while (mmap['R'] != 0 && mmap['D'] != 0 ) {
            for (auto &i : senate) {
                if (i != '0' && stk.empty()) {
                    stk.push(i);
                }else if (i == 'R' || i == 'D'){
                    if (i == stk.top()) {
                        stk.push(i);
                    }else {
                        mmap[i]--;
                        i = '0';
                        stk.pop();
                    }
                }
                if (mmap['R'] == 0 || mmap['D'] == 0) break;
            }
        }
        if (mmap['R'] == 0) return "Dire";
        return "Radiant";
    }
};
```

