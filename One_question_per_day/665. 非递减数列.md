# 2021-2-7

## [665. 非递减数列](https://leetcode-cn.com/problems/non-decreasing-array/)

给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 <= i <= n-2)，总满足 $nums[i] <= nums[i + 1]。$

示例 1:

输入: nums = [4,2,3]

输出: true

解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。

示例 2:

输入: nums = [4,2,1]

输出: false

解释: 你不能在只改变一个元素的情况下将其变为非递减数列。

说明：

$1 <= n <= 10 ^ 4$

$10 ^ 5 <= nums[i] <= 10 ^ 5$

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/non-decreasing-array

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路

#### 方法1：循环+记录

本题标签是简单题，但是细看不太简单，挺有意思的一道题。

我们循环遍历数组，对于每个坐标的元素值小于前一个坐标的元素值时，我们做如下判断，假设当前坐标为$i$。

- 判断$i-2$坐标的元素值是否小于等于$i$坐标的元素值，如果是的话，将$i-1$坐标的元素值修改为$i-2$坐标的元素值，表示在$i-1$坐标做一次修改即可使这个$i$坐标插入进来形成非递减数列。如果不是的话，我们就需要将$i$坐标的元素值修改为$i-1$坐标的元素值，使得其等于$i-1$坐标的元素值。这两种不同情况的策略都是为了贪心的使$i$坐标的值最小化，以至于后续能有更多的元素加入这个维护的非递减数列。
- 当我们的修改次数大于等于2时，直接返沪$flase$,表示一次修改不能使整个数组达到非递减数列。退出循环后返回$true$即可。
- 对于$i==1$,的情况，当$i=1$坐标的元素小于$i-1=0$坐标的元素时，我们只需要将修改次数加1即可。因为这里只有一种情况，就是将$i-1$的坐标元素修改为$i$坐标元素即可。



**时间复杂度**：$O(n)$，遍历一遍数组即可。

**空间复杂度**：$O(1)$，没有额外的空间消耗。

##### 代码

```cpp
class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
        int flag = 0;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] < nums[i - 1]) {
                if (flag) return false;
                if (i == 1) {
                    flag = 1;
                    nums[i - 1] = nums[i];
                }else {
                    flag = 1;
                    if (nums[i - 2] <= nums[i]) {
                        nums[i - 1] = nums[i - 2];
                    }else {
                        nums[i] = nums[i - 1];
                    }
                }
            }
        }
        return true;
    }
};
```

